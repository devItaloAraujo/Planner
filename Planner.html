<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <title>Planejador Semanal - Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'game-purple': '#8B5CF6',
                        'game-blue': '#3B82F6',
                        'game-green': '#10B981',
                        'game-orange': '#F59E0B',
                        'game-red': '#EF4444',
                        'game-pink': '#EC4899',
                        'game-cyan': '#06B6D4',
                        'dark-bg': '#0F0F23',
                        'dark-card': '#1A1A2E',
                        'dark-border': '#16213E',
                        'dark-text': '#E2E8F0',
                        'dark-muted': '#94A3B8'
                    },
                    fontFamily: {
                        'game': ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style>
        .block-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
        }
        .block-glow {
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }
        .grid-cell {
            min-height: 60px;
            border-right: 1px solid #16213E;
            border-bottom: 1px solid #3a486e;
            position: relative;
        }
        
        /* Hour column styling */
        .grid-cell[data-day="hora"] {
            background-color: #ffffff;
            border-color: #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .grid-cell[data-day="hora"]:hover {
            background-color: #f8fafc;
        }
        .time-block {
            position: absolute;
            left: 0;
            right: 0;
            border-radius: 8px;
            cursor: grab;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            z-index: 10;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 4px;
            box-sizing: border-box;
            user-select: none; /* Prevent text selection while dragging */
        }
        .time-block:active {
            cursor: grabbing;
        }
        .time-block:hover {
            transform: scale(1.02);
            z-index: 20;
        }
        .time-block.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 100;
        }
        .time-block.half-hour {
            font-size: 10px;
            margin-bottom: 1px;
        }
        .time-block.half-hour .block-name {
            font-size: 9px;
            line-height: 1.1;
            margin-bottom: 1px;
        }
        .time-block.half-hour .block-duration {
            font-size: 7px;
            opacity: 0.8;
        }
        .time-block.full-hour {
            /* Height will be set dynamically by JavaScript */
            min-height: 60px;
        }
        .time-block .block-name {
            font-weight: bold;
            font-size: 11px;
            line-height: 1.3;
            margin-bottom: 4px;
            word-wrap: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 2.6em;
        }
        .time-block .block-duration {
            font-size: 9px;
            opacity: 0.9;
        }
        
        /* Dynamic height classes for different durations */
        .time-block[style*="height: 30px"] {
            font-size: 8px;
        }
        .time-block[style*="height: 30px"] .block-name {
            font-size: 7px;
            line-height: 1.1;
        }
        .time-block[style*="height: 30px"] .block-duration {
            font-size: 6px;
        }
        
        .time-block[style*="height: 60px"] {
            font-size: 11px;
        }
        .time-block[style*="height: 60px"] .block-name {
            font-size: 11px;
            line-height: 1.3;
        }
        .time-block[style*="height: 60px"] .block-duration {
            font-size: 9px;
        }
        
        .time-block[style*="height: 90px"] {
            font-size: 12px;
        }
        .time-block[style*="height: 90px"] .block-name {
            font-size: 12px;
            line-height: 1.3;
        }
        .time-block[style*="height: 90px"] .block-duration {
            font-size: 10px;
        }
        
        .time-block[style*="height: 120px"] {
            font-size: 13px;
        }
        .time-block[style*="height: 120px"] .block-name {
            font-size: 13px;
            line-height: 1.3;
        }
        .time-block[style*="height: 120px"] .block-duration {
            font-size: 11px;
        }
        .time-block.selected {
            border-color: #8B5CF6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
        }
        .hour-marker {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            color: #1e293b;
            font-weight: 600;
            text-align: center;
        }
        .day-header {
            background: linear-gradient(135deg, #1A1A2E 0%, #16213E 100%);
            border-bottom: 2px solid #8B5CF6;
        }
        .bank-block {
            transition: all 0.2s ease;
            cursor: grab;
        }
        .bank-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .bank-block:active {
            cursor: grabbing;
        }
        .bank-block .font-bold {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }
        /* Minimizable sections */
        .minimizable-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .minimizable-content.minimized {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* Emoji picker overflow */
        #emojiPicker {
            position: fixed !important;
            z-index: 9999 !important;
        }
        
        .emoji-picker-container {
            position: relative;
            overflow: visible !important;
        }
        
        /* Snapshot card styles */
        .snapshot-card {
            background: linear-gradient(135deg, #1A1A2E 0%, #16213E 100%);
            border: 2px solid #16213E;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .snapshot-card:hover {
            border-color: #8B5CF6;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3);
        }
        
        .snapshot-thumbnail {
            width: 100%;
            height: 120px;
            background: #0F0F23;
            border-radius: 8px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid #16213E;
        }
        
        .snapshot-thumbnail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
            grid-template-rows: repeat(18, 1fr);
            height: 100%;
            gap: 1px;
        }
        
        .snapshot-thumbnail-cell {
            background: #1A1A2E;
            border: 1px solid #16213E;
            position: relative;
        }
        
        .snapshot-thumbnail-block {
            position: absolute;
            left: 0;
            right: 0;
            border-radius: 2px;
            font-size: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            overflow: hidden;
        }
        
        .snapshot-info {
            text-align: center;
        }
        
        .snapshot-name {
            font-weight: bold;
            font-size: 14px;
            color: #E2E8F0;
            margin-bottom: 4px;
        }
        
        .snapshot-date {
            font-size: 12px;
            color: #94A3B8;
        }
        
        .snapshot-delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(239, 68, 68, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .snapshot-card:hover .snapshot-delete-btn {
            opacity: 1;
        }
        
        .snapshot-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
        }
        /* Toasts */
        .toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 9999;
        }
        .toast-item {
            background: linear-gradient(135deg, #1A1A2E 0%, #16213E 100%);
            border: 1px solid #16213E;
            color: #E2E8F0;
            padding: 10px 12px;
            border-radius: 8px;
            min-width: 220px;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.25);
            display: flex;
            align-items: center;
            gap: 8px;
            animation: slideIn 0.2s ease;
        }
        .toast-item.success { border-left: 4px solid #10B981; }
        .toast-item.error { border-left: 4px solid #EF4444; }
        .toast-item.info { border-left: 4px solid #3B82F6; }
        @keyframes slideIn { from { transform: translateY(-6px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .toast-item.floating { position: fixed; z-index: 9999; }
        /* Make the small calendar icon in the Monday date input white (Chrome/Edge/Safari) */
        #mondayDate::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }
        
        /* Todo List Styles */
        .todo-item {
            background: linear-gradient(135deg, #1A1A2E 0%, #16213E 100%);
            border: 1px solid #16213E;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .todo-item:hover {
            border-color: #8B5CF6;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);
        }
        
        .todo-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #8B5CF6;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .todo-checkbox.checked {
            background: #8B5CF6;
            border-color: #8B5CF6;
        }
        
        .todo-checkbox.checked::after {
            content: '‚úì';
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .todo-text {
            flex: 1;
            color: #E2E8F0;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            transition: all 0.2s ease;
            min-width: 0; /* Allow flex item to shrink below content size */
        }
        
        .todo-text.completed {
            text-decoration: line-through;
            opacity: 0.6;
            color: #94A3B8;
        }
        
        .todo-edit-input {
            flex: 1;
            background: #0F0F23;
            border: 1px solid #8B5CF6;
            border-radius: 4px;
            padding: 8px;
            color: #E2E8F0;
            font-size: 14px;
            outline: none;
        }
        
        .todo-delete-btn {
            width: 24px;
            height: 24px;
            background: rgba(239, 68, 68, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .todo-item:hover .todo-delete-btn {
            opacity: 1;
        }
        
        .todo-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
        }
        
        /* Todo input textarea styling */
        #newTodoInput {
            min-height: 80px;
            line-height: 1.5;
        }
        
        /* Ensure button aligns with textarea on desktop */
        @media (min-width: 768px) {
            #addTodoBtn {
                align-self: flex-start;
                margin-top: 0;
            }
        }
        
        /* Todo tray button mobile styles */
        @media (max-width: 768px) {
            #todoTrayBtn span {
                display: none;
            }
            #todoTray {
                width: 100vw;
                max-width: 320px;
            }
        }
        
        /* Ensure minimize buttons maintain consistent width */
        .minimize-btn {
            min-width: 32px !important;
            width: 32px !important;
            flex-shrink: 0 !important;
        }
        
        /* Info card styles */
        .info-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: linear-gradient(135deg, #1A1A2E 0%, #16213E 100%);
            border: 2px solid #8B5CF6;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(139, 92, 246, 0.3);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            max-width: 500px;
            width: 90%;
        }
        
        .info-card.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            visibility: visible;
        }
        
        
        .time-slot-demo {
            display: flex;
            gap: 2px;
            margin: 12px 0;
        }
        
        .time-slot {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #16213E;
            background: #0F0F23;
            position: relative;
        }
        
        .time-slot.filled {
            background: #8B5CF6;
        }
        
        .time-slot.half {
            background: linear-gradient(45deg, #8B5CF6 50%, #0F0F23 50%);
        }
        
        .time-slot::after {
            content: attr(data-time);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #94A3B8;
            white-space: nowrap;
        }
        
        .info-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .info-backdrop.show {
            opacity: 1;
            visibility: visible;
        }
        
        /* Desktop width constraint for main sections */
        @media (min-width: 1024px) {
            .container.mx-auto {
                max-width: 80% !important;
            }
        }
        
        /* Mobile bank hint - hidden by default, show only on mobile */
        .mobile-bank-hint {
            display: none; /* Hidden by default */
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            color: #94A3B8;
            text-align: center;
            line-height: 1.4;
        }
        
        /* Show only on mobile */
        @media (max-width: 768px) {
            .mobile-bank-hint {
                display: block !important;
            }
        }
        
        @media (max-width: 768px) {
            .grid-cell {
                min-height: 60px;
            }
            .hour-marker {
                left: 50%;
                font-size: 10px;
            }
            .snapshot-thumbnail {
                height: 100px;
            }
            
            /* Mobile calendar section - maintain desktop proportions with horizontal scroll */
            .calendar-section {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: #8B5CF6 #16213E;
            }
            
            .calendar-section::-webkit-scrollbar {
                height: 8px;
            }
            
            .calendar-section::-webkit-scrollbar-track {
                background: #16213E;
                border-radius: 4px;
            }
            
            .calendar-section::-webkit-scrollbar-thumb {
                background: #8B5CF6;
                border-radius: 4px;
            }
            
            .calendar-section::-webkit-scrollbar-thumb:hover {
                background: #7C3AED;
            }
            
            .calendar-content {
                min-width: 1140px !important; /* Ensure minimum width to maintain desktop proportions (added 60px for 6:00 row) */
                width: max-content !important;
            }
            
            .calendar-content .grid-cols-8 {
                grid-template-columns: 80px repeat(7, 1fr); /* Fixed hour column + 7 equal day columns */
            }
            
            /* Override any conflicting overflow settings on mobile */
            .calendar-section.overflow-hidden {
                overflow-x: auto !important;
            }
            
            /* Mobile todo list improvements */
            .todo-item {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .todo-item > div:first-child {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .todo-text {
                font-size: 13px;
                line-height: 1.3;
                padding: 4px 0;
            }
            
            .todo-delete-btn {
                opacity: 1; /* Always visible on mobile for easier access */
                position: absolute;
                top: 8px;
                right: 8px;
            }
            
            .todo-item {
                position: relative;
                padding-right: 40px; /* Make space for delete button */
            }
            
            /* Always show snapshot delete button on mobile */
            .snapshot-delete-btn {
                opacity: 1 !important;
            }
        }
    </style>
</head>
<body class="bg-dark-bg text-dark-text font-game min-h-screen">
    <!-- Header -->
    <header class="bg-gradient-to-r from-dark-card to-dark-border p-4 shadow-lg">
        <div class="container mx-auto">
            <h1 class="text-2xl md:text-3xl font-bold text-white text-center leading-tight">
                <span class="block text-sky-300 text-3xl md:text-4xl">Planner</span>
                Planejador Semanal
            </h1>
            <p class="text-center text-dark-muted mt-2">
                Arraste e solte seus blocos de tempo para organizar sua semana
            </p>
        </div>
    </header>

    <div class="container mx-auto p-4">
        <div id="toastContainer" class="toast-container"></div>
        <!-- Custom Block Creator -->
        <div id="creatorSection" class="mb-6 bg-dark-card rounded-lg shadow-xl overflow-visible">
            <div class="p-6 pb-0 flex justify-between items-center mb-4">
                <div class="flex items-center">
                    <h2 class="text-xl font-bold text-game-cyan mb-2">
                        <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                            <circle cx="12" cy="12" r="9" stroke-width="1.8"></circle>
                            <path d="M12 8v8M16 12H8" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                        Criar Novo Bloco
                    </h2>
                    <button id="infoBtn" class="ml-1 w-4 h-4 bg-game-cyan hover:bg-cyan-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-200 hover:scale-110 -mt-6" title="Como funciona o sistema de blocos">
                        ?
                    </button>
                </div>
                <button id="minimizeCreatorBtn" class="minimize-btn bg-gray-700 hover:bg-gray-600 border border-gray-500 hover:border-gray-400 text-gray-300 hover:text-white transition-all duration-200 rounded-lg w-8 h-8 flex items-center justify-center text-lg font-bold shadow-sm m-2 mb-2">
                    <span id="creatorToggleIcon">‚àí</span>
                </button>
            </div>
            <div id="creatorContent" class="minimizable-content p-6 pt-4 relative">
                <!-- Info Card -->
                <div id="infoBackdrop" class="info-backdrop"></div>
                <div id="infoCard" class="info-card">
                    <div class="flex items-start justify-between mb-4">
                        <h3 class="text-lg font-bold text-game-purple flex items-center">
                            <span class="w-5 h-5 mr-2 text-center border border-game-purple rounded-full flex items-center justify-center text-xs">?</span>
                            Como Funciona o Sistema de Blocos
                        </h3>
                        <button id="closeInfoCard" class="text-gray-400 hover:text-white text-xl">&times;</button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-semibold text-white mb-2">‚è∞ Sistema de 30 Minutos</h4>
                            <p class="text-sm text-gray-300">Todos os blocos s√£o organizados em slots de 30 minutos. A dura√ß√£o m√≠nima √© 30 minutos.</p>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-white mb-2">üìù Atividades Curtas</h4>
                            <p class="text-sm text-gray-300">Para atividades menores que 30 minutos, voc√™ pode:</p>
                            <ul class="text-sm text-gray-300 mt-2 ml-4 space-y-1">
                                <li>‚Ä¢ Combinar 2 atividades no mesmo bloco</li>
                                <li>‚Ä¢ Usar o campo "Nome e Coment√°rios" para detalhar</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-white mb-2">üéØ Dicas Importantes</h4>
                            <ul class="text-sm text-gray-300 space-y-1">
                                <li>‚Ä¢ Dura√ß√µes: 30m, 1h, 1h30m, 2h, etc.</li>
                                <li>‚Ä¢ Arraste blocos para reposicionar</li>
                                <li>‚Ä¢ Clique em um bloco para editar</li>
                                <li>‚Ä¢ Blocos colocados na grade podem come√ßar em :00 ou :30</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium mb-2">S√≠mbolo:</label>
                    <div class="relative overflow-visible">
                        <button id="emojiPickerBtn" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-purple focus:outline-none text-center text-2xl hover:bg-dark-border transition-colors">
                            <span id="selectedEmoji">üéØ</span>
                        </button>
                        <div id="emojiPicker" class="absolute top-full left-0 mt-2 bg-dark-card border border-dark-border rounded-lg p-4 shadow-xl z-50 hidden max-w-xs overflow-visible">
                            <div class="grid grid-cols-6 gap-2 text-xl">
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üßò">üßò</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üçΩÔ∏è">üçΩÔ∏è</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üíº">üíº</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üèÉ">üèÉ</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üìö">üìö</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üéÆ">üéÆ</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üéµ">üéµ</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üé®">üé®</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üèãÔ∏è">üèãÔ∏è</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üõí">üõí</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üßπ">üßπ</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üç≥">üç≥</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üöó">üöó</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üí§">üí§</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üë•">üë•</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üì±">üì±</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üé¨">üé¨</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üå±">üå±</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üõçÔ∏è">üõçÔ∏è</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üè†">üè†</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="‚òï">‚òï</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üçï">üçï</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üéØ">üéØ</button>
                                <button class="emoji-option hover:bg-dark-border rounded p-2 transition-colors" data-emoji="üöø">üöø</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Nome e Coment√°rios:</label>
                    <textarea id="newBlockName" rows="3" placeholder="Nome do bloco e observa√ß√µes..." class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-purple focus:outline-none resize-y"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Dura√ß√£o (horas):</label>
                    <input type="number" id="newBlockDuration" min="0.5" max="12" step="0.5" value="1" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-purple focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Cor:</label>
                    <div class="grid grid-cols-4 gap-2">
                        <!-- Row 1: Blues -->
                        <button class="new-color-btn w-8 h-8 rounded-full bg-sky-400 border-2 border-transparent hover:border-white" data-color="sky-400"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-blue-500 border-2 border-transparent hover:border-white" data-color="blue-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-cyan-500 border-2 border-transparent hover:border-white" data-color="cyan-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-blue-700 border-2 border-transparent hover:border-white" data-color="blue-700"></button>

                        <!-- Row 2: Reds (moved from row 5) -->
                        <button class="new-color-btn w-8 h-8 rounded-full bg-red-400 border-2 border-transparent hover:border-white" data-color="red-400"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-red-500 border-2 border-transparent hover:border-white" data-color="red-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-rose-500 border-2 border-transparent hover:border-white" data-color="rose-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-red-600 border-2 border-transparent hover:border-white" data-color="red-600"></button>

                        <!-- Row 3: Greens (dark green replacing gray) -->
                        <button class="new-color-btn w-8 h-8 rounded-full bg-green-500 border-2 border-transparent hover:border-white" data-color="green-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-teal-500 border-2 border-transparent hover:border-white" data-color="teal-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-lime-500 border-2 border-transparent hover:border-white" data-color="lime-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-green-700 border-2 border-transparent hover:border-white" data-color="green-700"></button>

                        <!-- Row 4: Warms -->
                        <button class="new-color-btn w-8 h-8 rounded-full bg-yellow-500 border-2 border-transparent hover:border-white" data-color="yellow-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-orange-400 border-2 border-transparent hover:border-white" data-color="orange-400"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-orange-500 border-2 border-transparent hover:border-white" data-color="orange-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-orange-600 border-2 border-transparent hover:border-white" data-color="orange-600"></button>
                        
                        <!-- Row 5: Purples & Pinks (moved from row 2) -->
                        <button class="new-color-btn w-8 h-8 rounded-full bg-violet-500 border-2 border-transparent hover-border-white" data-color="violet-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-purple-500 border-2 border-transparent hover-border-white" data-color="purple-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-indigo-500 border-2 border-transparent hover-border-white" data-color="indigo-500"></button>
                        <button class="new-color-btn w-8 h-8 rounded-full bg-gray-500 border-2 border-transparent hover-border-white" data-color="gray-500"></button>
                    </div>
                </div>
            </div>
            <div class="mt-4">
                <button id="createBlockBtn" class="bg-game-green hover:bg-green-600 text-white py-3 px-6 rounded-lg transition-colors font-bold">
                    Criar Bloco
                </button>
            </div>
            </div>
        </div>

        <!-- Todo Tray Button -->
        <div class="fixed top-10 right-2 md:top-20 md:right-4 z-40">
            <button id="todoTrayBtn" class="bg-game-cyan hover:bg-cyan-600 text-white p-3 rounded-l-lg shadow-lg transition-all duration-300 hover:scale-105 flex items-center gap-2">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 12l2 2 4-4" stroke-linecap="round" stroke-linejoin="round"></path>
                    <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
                <span class="font-medium">Afazeres</span>
            </button>
        </div>

        <!-- Todo Tray -->
        <div id="todoTray" class="fixed top-0 right-0 h-full w-80 md:w-[28rem] bg-dark-card shadow-2xl transform translate-x-full transition-transform duration-300 z-50 border-l border-dark-border">
            <div class="p-6 h-full flex flex-col">
                <div class="flex items-center justify-between mb-6 flex-shrink-0">
                    <h2 class="text-xl font-bold text-game-cyan flex items-center">
                        <svg class="w-6 h-6 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 12l2 2 4-4" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z" stroke-linecap="round" stroke-linejoin="round"></path>
                        </svg>
                        Lista de Afazeres
                    </h2>
                    <button id="closeTodoTray" class="text-gray-400 hover:text-white text-xl">&times;</button>
                </div>
                
                <div class="mb-4 flex-shrink-0">
                    <div class="flex gap-2">
                        <textarea id="newTodoInput" rows="3" placeholder="Adicionar nova tarefa..." class="flex-1 p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-cyan focus:outline-none resize-y"></textarea>
                        <button id="addTodoBtn" class="bg-game-cyan hover:bg-cyan-600 text-white py-3 px-4 rounded-lg transition-colors font-bold">
                            +
                        </button>
                    </div>
                </div>
                
                <div id="todoList" class="space-y-2 flex-1 overflow-y-auto">
                    <!-- Todo items will be populated by JavaScript -->
                </div>
                
                <div id="noTodosMessage" class="text-center text-dark-muted py-8 hidden flex-1 flex items-center justify-center">
                    <div>
                        <div class="text-4xl mb-2">üìù</div>
                        <p>Nenhuma tarefa adicionada ainda.</p>
                        <p class="text-sm">Adicione sua primeira tarefa acima!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bank of Blocks -->
        <div id="bankSection" class="mb-6 bg-dark-card rounded-lg shadow-xl">
            <div class="p-6 pb-0 flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-game-cyan mb-2">
                    <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                        <rect x="4" y="4" width="7" height="7" rx="1.5" stroke-width="1.8"></rect>
                        <rect x="13" y="4" width="7" height="7" rx="1.5" stroke-width="1.8"></rect>
                        <rect x="4" y="13" width="7" height="7" rx="1.5" stroke-width="1.8"></rect>
                        <rect x="13" y="13" width="7" height="7" rx="1.5" stroke-width="1.8"></rect>
                    </svg>
                    Banco de Blocos
                </h2>
                <button id="minimizeBankBtn" class="minimize-btn bg-gray-700 hover:bg-gray-600 border border-gray-500 hover:border-gray-400 text-gray-300 hover:text-white transition-all duration-200 rounded-lg w-8 h-8 flex items-center justify-center text-lg font-bold shadow-sm m-2 mb-2">
                    <span id="bankToggleIcon">‚àí</span>
                </button>
            </div>
            <div id="bankContent" class="minimizable-content p-6 pt-4">
                <div class="mobile-bank-hint">
                    Voc√™ pode segurar um bloco com um dedo enquanto move a tela com outro.
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4" id="blockBank">
                    <!-- Blocks will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Calendar Grid -->
        <div class="bg-dark-card rounded-lg shadow-xl overflow-hidden calendar-section">
            <div class="calendar-content">
                <div class="day-header p-4 relative">
                    <h2 class="text-xl font-bold text-center">
                        <svg class="inline-block w-8 h-8 mr-2 mb-1 align-middle text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                            <rect x="3" y="5" width="18" height="16" rx="2" stroke-width="1.8"></rect>
                            <path d="M8 3v4M16 3v4M3 10h18" stroke-width="1.8" stroke-linecap="round"></path>
                        </svg>
                        Calend√°rio Semanal
                    </h2>
                    <div class="absolute top-4 right-4 flex gap-2">
                        <button id="saveWeekBtn" class="bg-game-green hover:bg-green-600 text-white p-2 rounded-lg transition-colors text-sm font-medium">
                            Salvar Captura
                        </button>
                        <button id="clearGridBtn" class="bg-game-red hover:bg-red-600 text-white p-2 rounded-lg transition-colors text-sm font-medium">
                            Limpar Grade
                        </button>
                    </div>
                </div>
                
                <!-- Days Header -->
                <div class="grid grid-cols-8 bg-dark-border">
                    <div class="p-3 text-center font-bold text-game-purple">Hora</div>
                    <div class="p-3 text-center font-bold">Segunda</div>
                    <div class="p-3 text-center font-bold">Ter√ßa</div>
                    <div class="p-3 text-center font-bold">Quarta</div>
                    <div class="p-3 text-center font-bold">Quinta</div>
                    <div class="p-3 text-center font-bold">Sexta</div>
                    <div class="p-3 text-center font-bold">S√°bado</div>
                    <div class="p-3 text-center font-bold">Domingo</div>
                </div>

                <!-- Calendar Grid -->
                <div class="relative">
                    <div class="grid grid-cols-8" id="calendarGrid">
                        <!-- Grid will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Snapshots Section -->
        <div id="snapshotsSection" class="mt-6 bg-dark-card rounded-lg shadow-xl">
            <div class="p-6 pb-0 flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-game-cyan mb-2">
                    <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                        <rect x="3" y="7" width="18" height="12" rx="2" stroke-width="1.8"></rect>
                        <path d="M7 7l2-3h6l2 3" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
                        <circle cx="12" cy="13" r="3.5" stroke-width="1.8"></circle>
                    </svg>
                    Capturas
                </h2>
                <button id="minimizeSnapshotsBtn" class="minimize-btn bg-gray-700 hover:bg-gray-600 border border-gray-500 hover:border-gray-400 text-gray-300 hover:text-white transition-all duration-200 rounded-lg w-8 h-8 flex items-center justify-center text-lg font-bold shadow-sm m-2 mb-2">
                    <span id="snapshotsToggleIcon">‚àí</span>
                </button>
            </div>
            <div id="snapshotsContent" class="minimizable-content p-6 pt-4">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4" id="snapshotsGrid">
                    <!-- Snapshots will be populated by JavaScript -->
                </div>
                <div id="noSnapshotsMessage" class="text-center text-dark-muted py-8 hidden">
                    <div class="text-4xl mb-2">üì∏</div>
                    <p>Nenhuma captura salva ainda.</p>
                    <p class="text-sm">Use o bot√£o "Salvar Semana" para criar sua primeira captura!</p>
                </div>
            </div>
        </div>
		
        <!-- Memory Card Section -->
        <div id="memoryCardSection" class="mt-6 bg-dark-card rounded-lg shadow-xl">
            <div class="p-6 pb-0 flex justify-between items-center mb-4">
                <div class="flex items-center">
                    <h2 class="text-xl font-bold text-game-cyan mb-2">
                        <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                            <path d="M6 3h9l3 3v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z" stroke-width="1.8" stroke-linejoin="round"></path>
                            <rect x="8" y="7" width="5" height="4" stroke-width="1.8"></rect>
                        </svg>
                        Memory Card
                    </h2>
                    <button id="memoryInfoBtn" class="ml-1 w-4 h-4 bg-game-cyan hover:bg-cyan-600 text-white rounded-full flex items-center justify-center text-xs font-bold transition-all duration-200 hover:scale-110 -mt-6" title="Como funciona o backup">
                        ?
                    </button>
                </div>
                <button id="minimizeMemoryCardBtn" class="minimize-btn bg-gray-700 hover:bg-gray-600 border border-gray-500 hover:border-gray-400 text-gray-300 hover:text-white transition-all duration-200 rounded-lg w-8 h-8 flex items-center justify-center text-lg font-bold shadow-sm m-2 mb-2">
                    <span id="memoryCardToggleIcon">+</span>
                </button>
            </div>
            <div id="memoryCardContent" class="minimizable-content p-6 pt-4 relative">
                <!-- Memory Info Card -->
                <div id="memoryInfoBackdrop" class="info-backdrop"></div>
                <div id="memoryInfoCard" class="info-card">
                    <div class="flex items-start justify-between mb-4">
                        <h3 class="text-lg font-bold text-game-purple flex items-center">
                            <span class="w-5 h-5 mr-2 text-center border border-game-purple rounded-full flex items-center justify-center text-xs">?</span>
                            Como Funciona o Backup
                        </h3>
                        <button id="closeMemoryInfoCard" class="text-gray-400 hover:text-white text-xl">&times;</button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-semibold text-white mb-2">üíæ Onde Ficam Salvos os Dados</h4>
                            <p class="text-sm text-gray-300">Seus dados ficam salvos no seu navegador (Chrome, Firefox, etc.) em um local chamado "Local Storage". √â como um arquivo tempor√°rio que fica no seu computador ou celular.</p>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-white mb-2">‚ö†Ô∏è Quando os Dados Podem Ser Perdidos</h4>
                            <ul class="text-sm text-gray-300 space-y-1">
                                <li>‚Ä¢ Limpar dados do navegador</li>
                                <li>‚Ä¢ Usar modo inc√≥gnito/privado</li>
                                <li>‚Ä¢ Desinstalar o navegador</li>
                                <li>‚Ä¢ Formatar o computador/celular</li>
                                <li>‚Ä¢ Usar outro navegador</li>
                            </ul>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold text-white mb-2">üõ°Ô∏è Como se Proteger</h4>
                            <ul class="text-sm text-gray-300 space-y-1">
                                <li>‚Ä¢ Use o "Exportar - Copiar" regularmente</li>
                                <li>‚Ä¢ Cole o texto em um arquivo de texto</li>
                                <li>‚Ä¢ Salve em um local seguro (Google Drive, etc.)</li>
                                <li>‚Ä¢ Fa√ßa backup antes de limpar o navegador</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <p class="text-dark-muted mb-3">Copie e cole os dados formatados para salvar ou restaurar todo o planner.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-2 text-game-green">Dados para Exportar</label>
                        <textarea id="exportTextarea" rows="4" readonly class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text resize-y" placeholder="Clique em 'Exportar - Copiar' para gerar os dados compactos..."></textarea>
                        <button id="exportMemoryBtn" class="w-full mt-2 bg-game-green hover:bg-green-600 text-white py-2 px-4 rounded-lg transition-colors">Exportar - Copiar</button>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2 text-game-blue">Dados para Importar</label>
                        <textarea id="importTextarea" rows="4" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text resize-y" placeholder="Cole aqui os dados compactos do Memory Card..."></textarea>
                        <div class="flex gap-2 mt-2">
                            <button id="importMemoryBtn" class="flex-1 bg-game-blue hover:bg-blue-600 text-white py-2 px-4 rounded-lg transition-colors">Importar</button>
                            <button id="clearImportBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">Limpar</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Support / Donate Section -->
        <div id="supportSection" class="mt-6 bg-dark-card rounded-lg shadow-xl">
            <div class="p-6 pb-0 flex justify-between items-center mb-4">
                <h2 id="supportTitle" class="text-xl font-bold text-game-cyan mb-2">
                    <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                        <path d="M4 7h12v7a5 5 0 0 1-5 5H9a5 5 0 0 1-5-5V7z" stroke-width="1.8" stroke-linejoin="round"></path>
                        <path d="M16 9h2.5a2.5 2.5 0 0 1 0 5H16" stroke-width="1.8" stroke-linecap="round"></path>
                    </svg>
                    <span id="supportTitleText">Pague um caf√© para o criador</span>
                </h2>
                <button id="minimizeSupportBtn" class="minimize-btn bg-gray-700 hover:bg-gray-600 border border-gray-500 hover:border-gray-400 text-gray-300 hover:text-white transition-all duration-200 rounded-lg w-8 h-8 flex items-center justify-center text-lg font-bold shadow-sm m-2 mb-2">
                    <span id="supportToggleIcon">‚àí</span>
                </button>
            </div>
            <div id="supportContent" class="minimizable-content p-6 pt-4">
                <p id="supportDescription" class="text-dark-muted mb-4">Se esta ferramenta te ajudou, considere apoiar com qualquer valor via PIX.</p>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-start">
                    <!-- PIX Key + Copy -->
                    <div>
                        <label class="block text-sm font-medium mb-2">Chave PIX:</label>
                        <input id="pixKeyInput" type="text" readonly class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text select-all">
                        <div class="text-xs text-dark-muted mt-2">Copie a chave PIX acima ou use o QR code.</div>
                    </div>

                    <!-- QR Preview -->
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium mb-2">QR Code do PIX:</label>
                        <div class="bg-dark-bg border border-dark-border rounded-lg p-3 flex items-center gap-4">
                            <img id="pixQrImg" src="https://raw.githubusercontent.com/devItaloAraujo/imageFolder/refs/heads/main/QrCodePix.png" alt="QR Code PIX" class="w-32 h-32 object-contain rounded cursor-pointer border border-dark-border" title="Clique para ampliar">
                            <div class="text-sm text-dark-muted">
                                <div class="font-semibold text-dark-text mb-1">Como usar</div>
                                <ul class="list-disc ml-5 space-y-1">
                                    <li>Abra seu app banc√°rio e escolha pagar por QR Code.</li>
                                    <li>Aponte a c√¢mera para o QR ao lado e confirme o valor.</li>
                                    <li>Se preferir, copie a chave PIX e cole no app.</li>
                                </ul>
                                <button id="openPixModalBtn" class="mt-3 bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded">Ampliar QR</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="supportFooter" class="text-xs text-dark-muted mt-4">Obrigado pelo apoio! Ele ajuda a manter e criar novas ferramentas √∫teis. üíú</div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-red">‚ö†Ô∏è Confirmar Exclus√£o</h3>
            <p class="mb-6 text-dark-muted">Tem certeza que deseja remover este bloco do banco? Esta a√ß√£o n√£o pode ser desfeita.</p>
            
            <div class="flex gap-3">
                <button id="confirmDeleteBtn" class="flex-1 bg-game-red hover:bg-red-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Deletar
                </button>
                <button id="cancelDeleteBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Cancelar
                </button>
            </div>
        </div>
    </div>

    <!-- Clear Grid Confirmation Modal -->
    <div id="clearGridModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-red">‚ö†Ô∏è Limpar Toda a Grade Semanal</h3>
            <p class="mb-6 text-dark-muted">Tem certeza que deseja remover TODOS os blocos da grade semanal? Esta a√ß√£o n√£o pode ser desfeita e ir√° apagar todo o seu planejamento semanal.</p>
            
            <div class="flex gap-3">
                <button id="confirmClearBtn" class="flex-1 bg-game-red hover:bg-red-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Limpar Tudo
                </button>
                <button id="cancelClearBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Cancelar
                </button>
            </div>
        </div>
    </div>

    <!-- Block Edit Modal -->
    <div id="blockModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-cyan">Editar Bloco</h3>
            
            <div class="mb-4">
                <label class="block text-sm font-medium mb-2">Nome do Bloco e Coment√°rios:</label>
                <textarea id="blockName" rows="4" placeholder="T√≠tulo do bloco e observa√ß√µes..." class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-purple focus:outline-none resize-y"></textarea>
            </div>
            
            <div class="mb-4">
                <label class="block text-sm font-medium mb-2">Dura√ß√£o (horas):</label>
                <input type="number" id="blockDuration" min="0.5" max="12" step="0.5" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-purple focus:outline-none">
            </div>
            
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Cor:</label>
                <div class="grid grid-cols-4 gap-2">
                    <!-- Row 1: Blues -->
                    <button class="color-btn w-8 h-8 rounded-full bg-sky-400 border-2 border-transparent hover:border-white" data-color="sky-400"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-blue-500 border-2 border-transparent hover:border-white" data-color="blue-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-cyan-500 border-2 border-transparent hover:border-white" data-color="cyan-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-blue-700 border-2 border-transparent hover:border-white" data-color="blue-700"></button>

                    <!-- Row 2: Reds (moved from row 5) -->
                    <button class="color-btn w-8 h-8 rounded-full bg-red-400 border-2 border-transparent hover:border-white" data-color="red-400"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-red-500 border-2 border-transparent hover:border-white" data-color="red-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-rose-500 border-2 border-transparent hover:border-white" data-color="rose-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-red-600 border-2 border-transparent hover:border-white" data-color="red-600"></button>

                    <!-- Row 3: Greens (dark green replacing gray) -->
                    <button class="color-btn w-8 h-8 rounded-full bg-green-500 border-2 border-transparent hover:border-white" data-color="green-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-teal-500 border-2 border-transparent hover:border-white" data-color="teal-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-lime-500 border-2 border-transparent hover:border-white" data-color="lime-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-green-700 border-2 border-transparent hover:border-white" data-color="green-700"></button>

                    <!-- Row 4: Warms -->
                    <button class="color-btn w-8 h-8 rounded-full bg-yellow-500 border-2 border-transparent hover:border-white" data-color="yellow-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-orange-400 border-2 border-transparent hover:border-white" data-color="orange-400"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-orange-500 border-2 border-transparent hover:border-white" data-color="orange-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-orange-600 border-2 border-transparent hover:border-white" data-color="orange-600"></button>

                    <!-- Row 5: Purples & Pinks (moved from row 2) -->
                    <button class="color-btn w-8 h-8 rounded-full bg-violet-500 border-2 border-transparent hover:border-white" data-color="violet-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-purple-500 border-2 border-transparent hover:border-white" data-color="purple-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-indigo-500 border-2 border-transparent hover:border-white" data-color="indigo-500"></button>
                    <button class="color-btn w-8 h-8 rounded-full bg-gray-500 border-2 border-transparent hover:border-white" data-color="gray-500"></button>
                </div>
            </div>
            
            <div class="flex gap-3">
                <button id="saveBtn" class="flex-1 bg-game-green hover:bg-green-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Salvar
                </button>
                <button id="deleteBtn" class="flex-1 bg-game-red hover:bg-red-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Deletar
                </button>
            </div>
            
            <button id="closeModal" class="absolute top-4 right-4 text-dark-muted hover:text-white text-xl">
                ‚úï
            </button>
        </div>
    </div>

    <!-- Save Snapshot Modal -->
    <div id="saveSnapshotModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-green">
                <svg class="inline-block w-8 h-8 mr-2 mb-1 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                    <rect x="3" y="7" width="18" height="12" rx="2" stroke-width="1.8"></rect>
                    <path d="M7 7l2-3h6l2 3" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
                    <circle cx="12" cy="13" r="3.5" stroke-width="1.8"></circle>
                </svg>
                Salvar Captura
            </h3>
            <p class="mb-4 text-dark-muted">Digite a data da segunda-feira da semana que deseja salvar:</p>
            
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Data da Segunda-feira:</label>
                <input type="date" id="mondayDate" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-green focus:outline-none">
            </div>

            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">D√™ um nome pra essa captura (opcional):</label>
                <input type="text" id="snapshotDescription" maxlength="100" placeholder="Ex.: Semana de entregas importantes" class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-green focus:outline-none">
            </div>
            
            <div class="flex gap-3">
                <button id="confirmSaveBtn" class="flex-1 bg-game-green hover:bg-green-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Salvar
                </button>
                <button id="cancelSaveBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Cancelar
                </button>
            </div>
            
            <button id="closeSaveModal" class="absolute top-4 right-4 text-dark-muted hover:text-white text-xl">
                ‚úï
            </button>
        </div>
    </div>

    <!-- Load Snapshot Modal -->
    <div id="loadSnapshotModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-blue">üì• Carregar Captura</h3>
            <p class="mb-6 text-dark-muted">Tem certeza que deseja carregar esta captura? O planejamento atual ser√° substitu√≠do.</p>
            
            <div class="mb-4 p-3 bg-dark-bg rounded-lg border border-dark-border">
                <div class="text-sm text-dark-muted mb-1">Captura selecionada:</div>
                <div id="selectedSnapshotName" class="font-bold text-game-blue"></div>
            </div>

                <div id="selectedSnapshotDescriptionWrapper" class="mb-4 p-3 bg-dark-bg rounded-lg border border-dark-border hidden">
                    <div class="text-sm text-dark-muted mb-1">Nome da captura:</div>
                    <div id="selectedSnapshotDescription" class="font-medium text-dark-text"></div>
                </div>

                <div class="mb-4 p-3 bg-dark-bg rounded-lg border border-dark-border">
                    <label for="snapshotWeekComments" class="block text-sm font-medium mb-2">Coment√°rios da semana (salvos automaticamente):</label>
                    <textarea id="snapshotWeekComments" rows="4" placeholder="Anote insights e coment√°rios da semana..." class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text focus:border-game-blue focus:outline-none resize-y"></textarea>
                </div>
            
            <div class="flex gap-3">
                <button id="confirmLoadBtn" class="flex-1 bg-game-blue hover:bg-blue-600 text-white py-2 px-4 rounded-lg transition-colors">Carregar</button>
                <button id="cancelLoadBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">
                    Cancelar
                </button>
            </div>
            
            <button id="closeLoadModal" class="absolute top-4 right-4 text-dark-muted hover:text-white text-xl">
                ‚úï
            </button>
        </div>
    </div>

    <!-- PIX QR Modal -->
    <div id="pixModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-dark-card rounded-lg p-6 w-full max-w-lg shadow-2xl">
            <h3 class="text-xl font-bold mb-4 text-game-pink">‚òï PIX - Apoie essa ferramenta</h3>
            <div class="flex flex-col items-center">
                <img id="pixModalImg" src="https://raw.githubusercontent.com/devItaloAraujo/imageFolder/refs/heads/main/QrCodePix.png" alt="QR Code PIX" class="w-72 h-72 object-contain rounded border border-dark-border" />
                    <div class="w-full mt-4">
                        <label class="block text-sm font-medium mb-2">Chave PIX:</label>
                        <input id="pixKeyInputModal" type="text" readonly class="w-full p-3 bg-dark-bg border border-dark-border rounded-lg text-dark-text select-all">
                    </div>
            </div>
            <button id="closePixModal" class="absolute top-4 right-4 text-dark-muted hover:text-white text-xl">‚úï</button>
        </div>
    </div>

    <script>
        class WeeklyPlanner {
            constructor() {
                this.blocks = [];
                this.currentBlock = null;
                this.draggedBlock = null;
                this.isDragging = false;
                this.touchStartY = 0;
                this.touchStartX = 0;
                this.lastClickPosition = null;
                // Support section state
                this.supportConfig = null;
                
                this.hours = [];
                this.hours.push(6); // Add 6:00 at the start
                for (let i = 7; i <= 23; i++) {
                    this.hours.push(i);
                }
                this.hours.push(0); // Add 0:00 at the end
                
                this.days = ['Segunda', 'Ter√ßa', 'Quarta', 'Quinta', 'Sexta', 'S√°bado', 'Domingo'];
                
                this.predefinedBlocks = [
                    { name: 'üßò Medita√ß√£o', duration: 1, color: 'game-purple' },
                    { name: 'üçΩÔ∏è Almo√ßo', duration: 1, color: 'game-orange' },
                    { name: 'üíº Trabalho', duration: 1, color: 'game-green' }
                ];
                
                this.customBlocks = [];
                this.selectedNewColor = 'purple-500';
                this.selectedEmoji = 'üéØ';
                this.blockToDelete = null;
                this.blockToDeleteIsPredefined = false;
                this.removedPredefinedBlockNames = [];
                this.predefinedBlockModifications = {};
                this.isEditingBankBlock = false;
                this.editingBankBlockIndex = null;
                this.editingBankBlockIsPredefined = false;
                
                // Snapshots functionality
                this.snapshots = [];
                this.selectedSnapshot = null;
                
                // Todo list functionality
                this.todos = [];
                this.editingTodoId = null;
                
                this.init();
            }

            // ===== Support Section =====
            setupSupportSection() {
                const titleEl = document.getElementById('supportTitle');
                const descEl = document.getElementById('supportDescription');
                const pixKeyInput = document.getElementById('pixKeyInput');
                const pixKeyInputModal = document.getElementById('pixKeyInputModal');
                const qrImg = document.getElementById('pixQrImg');
                const qrImgModal = document.getElementById('pixModalImg');
                const openModalBtn = document.getElementById('openPixModalBtn');
                const modal = document.getElementById('pixModal');
                const closeModalBtn = document.getElementById('closePixModal');

                if (!titleEl || !descEl || !pixKeyInput || !qrImg) return;

                // Populate UI
                const titleSpan = document.getElementById('supportTitleText');
                if (titleSpan) {
                    titleSpan.textContent = this.supportConfig.title;
                } else {
                    titleEl.textContent = this.supportConfig.title;
                }
                descEl.textContent = this.supportConfig.description;
                pixKeyInput.value = this.supportConfig.pixKey;
                if (pixKeyInputModal) pixKeyInputModal.value = this.supportConfig.pixKey;
                qrImg.src = this.supportConfig.qrSrc;
                if (qrImgModal) qrImgModal.src = this.supportConfig.qrSrc;

                const openModal = () => { if (modal) modal.classList.remove('hidden'); };
                const closeModal = () => { if (modal) modal.classList.add('hidden'); };

                if (openModalBtn) openModalBtn.addEventListener('click', openModal);
                if (qrImg) qrImg.addEventListener('click', openModal);
                if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
                if (modal) {
                    modal.addEventListener('click', (e) => { if (e.target.id === 'pixModal') closeModal(); });
                }
            }

            // Ensure durations are restricted to 30-minute increments
            roundToHalf(value) {
                if (typeof value !== 'number' || isNaN(value)) return NaN;
                return Math.max(0.5, Math.min(12, Math.round(value * 2) / 2));
            }

            isHalfHourMultiple(value) {
                if (typeof value !== 'number' || isNaN(value)) return false;
                return Math.abs(value * 2 - Math.round(value * 2)) < 1e-9; // floating point tolerance
            }
            
            init() {
                this.createCalendarGrid();
                this.loadRemovedPredefinedBlocks();
                this.loadPredefinedBlockModifications();
                this.createBlockBank();
                this.setupEventListeners();
                this.loadBlocks();
                this.loadCustomBlocks();
                this.setDefaultColor();
                this.setupMinimizeButtons();
                this.loadMinimizeStates();
                this.loadSnapshots();
                this.renderSnapshots();
                this.populateExportField();
                this.loadTodos();
                this.renderTodos();
                // Support section config and setup
                this.supportConfig = {
                    title: 'Pague um caf√© para o criador',
                    description: 'Se esta ferramenta te ajudou, considere apoiar com qualquer valor via PIX.',
                    pixKey: 'italojsouza@gmail.com',
                    qrSrc: 'https://raw.githubusercontent.com/devItaloAraujo/imageFolder/refs/heads/main/QrCodePix.png'
                };
                this.setupSupportSection();
            }
            // ===== Toasts & Confirm =====
            showToast(message, type = 'info', timeoutMs = 2500) {
                const container = document.getElementById('toastContainer');
                if (!container) return;
                const item = document.createElement('div');
                item.className = `toast-item ${type}`;
                item.textContent = message;

                const useFloating = this.lastClickPosition && Number.isFinite(this.lastClickPosition.x) && Number.isFinite(this.lastClickPosition.y);
                if (useFloating) {
                    item.classList.add('floating');
                    const padding = 12;
                    const estimatedWidth = 260;
                    const estimatedHeight = 56;
                    const maxX = window.innerWidth - estimatedWidth - padding;
                    const maxY = window.innerHeight - estimatedHeight - padding;
                    const x = Math.max(padding, Math.min(this.lastClickPosition.x + 12, maxX));
                    const y = Math.max(padding, Math.min(this.lastClickPosition.y + 12, maxY));
                    item.style.left = `${x}px`;
                    item.style.top = `${y}px`;
                    document.body.appendChild(item);
                } else {
                    container.appendChild(item);
                }

                setTimeout(() => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateY(-6px)';
                    setTimeout(() => item.remove(), 150);
                }, timeoutMs);
            }

            async confirmModal(message, confirmText = 'Confirmar', cancelText = 'Cancelar', variant = 'default') {
                return new Promise(resolve => {
                    // Build ephemeral confirm modal matching theme
                    const overlay = document.createElement('div');
                    overlay.className = 'fixed inset-0 bg-black bg-opacity-50 z-[9998] flex items-center justify-center p-4';
                    const modal = document.createElement('div');
                    modal.className = 'bg-dark-card rounded-lg p-6 w-full max-w-md shadow-2xl border border-dark-border';
                    const isDanger = variant === 'danger';
                    modal.innerHTML = `
                        <h3 class="text-xl font-bold mb-4 ${isDanger ? 'text-game-red' : 'text-game-purple'}">‚ö†Ô∏è Confirma√ß√£o</h3>
                        <p class="mb-6 text-dark-muted">${message}</p>
                        <div class="flex gap-3">
                            <button class="confirmBtn flex-1 ${isDanger ? 'bg-game-red hover:bg-red-600' : 'bg-game-blue hover:bg-blue-600'} text-white py-2 px-4 rounded-lg transition-colors">${confirmText}</button>
                            <button class="cancelBtn flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">${cancelText}</button>
                        </div>
                    `;
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    const cleanup = (value) => { overlay.remove(); resolve(value); };
                    modal.querySelector('.confirmBtn').addEventListener('click', () => cleanup(true));
                    modal.querySelector('.cancelBtn').addEventListener('click', () => cleanup(false));
                    overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(false); });
                });
            }


            // ===== Half-hour grid helpers =====
            getHourIndex(hour) {
                return this.hours.indexOf(hour);
            }

            // Convert a (hour, startHalf) into a half-slot index within the day
            toHalfSlotIndex(hour, startHalf) {
                const hourIndex = this.getHourIndex(hour);
                if (hourIndex === -1) return -1;
                return hourIndex * 2 + (startHalf ? 1 : 0);
            }

            // Convert half-slot index back to (hour, startHalf)
            fromHalfSlotIndex(slotIndex) {
                const hourIndex = Math.floor(slotIndex / 2);
                const startHalf = slotIndex % 2 === 1;
                const hour = this.hours[hourIndex];
                return { hour, startHalf };
            }

            // Compute if block occupies any existing half slots in the given day
            doesOverlapInHalfSlots(block, targetHour, targetDay, targetStartHalf) {
                // Gather occupied slots for the day excluding this block
                const occupied = new Set();
                this.blocks.forEach(other => {
                    if (other.id === block.id) return;
                    if (other.day !== targetDay) return;
                    const otherStartHalf = !!other.startHalf;
                    const start = this.toHalfSlotIndex(other.hour, otherStartHalf);
                    const span = Math.round(other.duration * 2);
                    for (let i = 0; i < span; i++) occupied.add(start + i);
                });

                const start = this.toHalfSlotIndex(targetHour, !!targetStartHalf);
                const span = Math.round(block.duration * 2);
                // Out of range
                if (start < 0 || start + span > this.hours.length * 2) return true;
                for (let i = 0; i < span; i++) {
                    if (occupied.has(start + i)) return true;
                }
                return false;
            }

            // Find next available position in half-hour resolution starting from a preferred (hour, half)
            findAlternativeHalfPosition(block, preferredHour, preferredDay, preferredStartHalf) {
                const totalSlots = this.hours.length * 2;
                const startSlot = Math.max(0, this.toHalfSlotIndex(preferredHour, !!preferredStartHalf));
                const span = Math.round(block.duration * 2);
                for (let slot = startSlot; slot + span <= totalSlots; slot++) {
                    const { hour, startHalf } = this.fromHalfSlotIndex(slot);
                    if (!this.doesOverlapInHalfSlots(block, hour, preferredDay, startHalf)) {
                        return { hour, day: preferredDay, startHalf };
                    }
                }
                return null;
            }
            
            createCalendarGrid() {
                const grid = document.getElementById('calendarGrid');
                grid.innerHTML = '';
                
                this.hours.forEach(hour => {
                    // Hour marker
                    const hourCell = document.createElement('div');
                    hourCell.className = 'grid-cell relative';
                    hourCell.dataset.day = 'hora';
                    hourCell.innerHTML = `<div class="hour-marker">${hour.toString().padStart(2, '0')}:00</div>`;
                    grid.appendChild(hourCell);
                    
                    // Day cells
                    for (let day = 0; day < 7; day++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.hour = hour;
                        cell.dataset.day = day;
                        cell.addEventListener('dragover', (e) => this.handleDragOver(e));
                        cell.addEventListener('drop', (e) => this.handleDrop(e));
                        cell.addEventListener('click', (e) => this.handleCellClick(e));
                        grid.appendChild(cell);
                    }
                });
            }
            
            setupMinimizeButtons() {
                // Creator minimize button
                const minimizeCreatorBtn = document.getElementById('minimizeCreatorBtn');
                const creatorContent = document.getElementById('creatorContent');
                const creatorToggleIcon = document.getElementById('creatorToggleIcon');
                const creatorSection = document.getElementById('creatorSection');
                
                minimizeCreatorBtn.addEventListener('click', () => {
                    this.toggleMinimize('creator', creatorContent, creatorToggleIcon);
                });
                // Expand on section click when minimized
                creatorSection.addEventListener('click', (e) => {
                    if (e.target.closest('#minimizeCreatorBtn')) return;
                    if (creatorContent.classList.contains('minimized')) {
                        this.toggleMinimize('creator', creatorContent, creatorToggleIcon);
                    }
                });
                
                // Bank minimize button
                const minimizeBankBtn = document.getElementById('minimizeBankBtn');
                const bankContent = document.getElementById('bankContent');
                const bankToggleIcon = document.getElementById('bankToggleIcon');
                const bankSection = document.getElementById('bankSection');
                
                minimizeBankBtn.addEventListener('click', () => {
                    this.toggleMinimize('bank', bankContent, bankToggleIcon);
                });
                // Expand on section click when minimized
                bankSection.addEventListener('click', (e) => {
                    if (e.target.closest('#minimizeBankBtn')) return;
                    if (bankContent.classList.contains('minimized')) {
                        this.toggleMinimize('bank', bankContent, bankToggleIcon);
                    }
                });
                
                // Snapshots minimize button
                const minimizeSnapshotsBtn = document.getElementById('minimizeSnapshotsBtn');
                const snapshotsContent = document.getElementById('snapshotsContent');
                const snapshotsToggleIcon = document.getElementById('snapshotsToggleIcon');
                const snapshotsSection = document.getElementById('snapshotsSection');
                
                minimizeSnapshotsBtn.addEventListener('click', () => {
                    this.toggleMinimize('snapshots', snapshotsContent, snapshotsToggleIcon);
                });
                // Expand on section click when minimized
                snapshotsSection.addEventListener('click', (e) => {
                    if (e.target.closest('#minimizeSnapshotsBtn')) return;
                    if (snapshotsContent.classList.contains('minimized')) {
                        this.toggleMinimize('snapshots', snapshotsContent, snapshotsToggleIcon);
                        // Scroll into view after expanding
                        snapshotsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });

                // Support minimize button
                const minimizeSupportBtn = document.getElementById('minimizeSupportBtn');
                const supportContent = document.getElementById('supportContent');
                const supportToggleIcon = document.getElementById('supportToggleIcon');
                const supportSection = document.getElementById('supportSection');

                if (minimizeSupportBtn && supportContent && supportToggleIcon && supportSection) {
                    minimizeSupportBtn.addEventListener('click', () => {
                        this.toggleMinimize('support', supportContent, supportToggleIcon);
                    });
                    // Expand on section click when minimized
                    supportSection.addEventListener('click', (e) => {
                        if (e.target.closest('#minimizeSupportBtn')) return;
                        if (supportContent.classList.contains('minimized')) {
                            this.toggleMinimize('support', supportContent, supportToggleIcon);
                        }
                    });
                }


                // Memory Card minimize button
                const minimizeMemoryCardBtn = document.getElementById('minimizeMemoryCardBtn');
                const memoryCardContent = document.getElementById('memoryCardContent');
                const memoryCardToggleIcon = document.getElementById('memoryCardToggleIcon');
                const memoryCardSection = document.getElementById('memoryCardSection');

                if (minimizeMemoryCardBtn && memoryCardContent && memoryCardToggleIcon && memoryCardSection) {
                    minimizeMemoryCardBtn.addEventListener('click', () => {
                        this.toggleMinimize('memoryCard', memoryCardContent, memoryCardToggleIcon);
                    });
                    // Expand on section click when minimized
                    memoryCardSection.addEventListener('click', (e) => {
                        if (e.target.closest('#minimizeMemoryCardBtn')) return;
                        if (memoryCardContent.classList.contains('minimized')) {
                            this.toggleMinimize('memoryCard', memoryCardContent, memoryCardToggleIcon);
                        }
                    });
                }
            }
            
            toggleMinimize(section, content, icon) {
                const isMinimized = content.classList.contains('minimized');
                
                if (isMinimized) {
                    content.classList.remove('minimized');
                    icon.textContent = '‚àí';
                    
                    // If expanding Memory Card section, refresh export data
                    if (section === 'memoryCard') {
                        this.populateExportField();
                    }
                } else {
                    content.classList.add('minimized');
                    icon.textContent = '+';
                }
                
                // Save state
                this.saveMinimizeState(section, !isMinimized);
            }
            
            saveMinimizeState(section, isMinimized) {
                // Do not persist Memory Card section state across sessions
                if (section === 'memoryCard') return;
                const states = JSON.parse(localStorage.getItem('minimizeStates') || '{}');
                states[section] = isMinimized;
                localStorage.setItem('minimizeStates', JSON.stringify(states));
            }
            
            loadMinimizeStates() {
                const states = JSON.parse(localStorage.getItem('minimizeStates') || '{}');
                
                // Load creator state
                const creatorContent = document.getElementById('creatorContent');
                const creatorToggleIcon = document.getElementById('creatorToggleIcon');
                if (states.creator) {
                    creatorContent.classList.add('minimized');
                    creatorToggleIcon.textContent = '+';
                }
                
                // Load bank state
                const bankContent = document.getElementById('bankContent');
                const bankToggleIcon = document.getElementById('bankToggleIcon');
                if (states.bank) {
                    bankContent.classList.add('minimized');
                    bankToggleIcon.textContent = '+';
                }

                // Load snapshots state
                const snapshotsContent = document.getElementById('snapshotsContent');
                const snapshotsToggleIcon = document.getElementById('snapshotsToggleIcon');
                if (states.snapshots && snapshotsContent && snapshotsToggleIcon) {
                    snapshotsContent.classList.add('minimized');
                    snapshotsToggleIcon.textContent = '+';
                }

                // Load support state
                const supportContent = document.getElementById('supportContent');
                const supportToggleIcon = document.getElementById('supportToggleIcon');
                if (states.support && supportContent && supportToggleIcon) {
                    supportContent.classList.add('minimized');
                    supportToggleIcon.textContent = '+';
                }


                // Memory Card: always start minimized (don't read persisted state)
                const memoryCardContent = document.getElementById('memoryCardContent');
                const memoryCardToggleIcon = document.getElementById('memoryCardToggleIcon');
                if (memoryCardContent && memoryCardToggleIcon) {
                    memoryCardContent.classList.add('minimized');
                    memoryCardToggleIcon.textContent = '+';
                }
            }
            
            createBlockBank() {
                const bank = document.getElementById('blockBank');
                bank.innerHTML = '';
                
                // Add predefined blocks with modifications applied
                const visiblePredefined = this.predefinedBlocks.filter(block => !this.removedPredefinedBlockNames.includes(block.name));
                visiblePredefined.forEach((block, index) => {
                    // Apply any saved modifications to this block
                    const modifiedBlock = this.getModifiedPredefinedBlock(block);
                    const bankBlock = this.createBankBlockElement(modifiedBlock, index, true);
                    bank.appendChild(bankBlock);
                });
                
                // Add custom blocks
                this.customBlocks.forEach((block, index) => {
                    const bankBlock = this.createBankBlockElement(block, index, false);
                    bank.appendChild(bankBlock);
                });
            }
            
            createBankBlockElement(block, index, isPredefined) {
                const bankBlock = document.createElement('div');
                bankBlock.className = `bank-block bg-${block.color} text-white p-4 rounded-lg block-shadow cursor-grab relative`;
                bankBlock.innerHTML = `
                    <div class="font-bold">${block.name}</div>
                    ${block.duration !== 0.5 ? `<div class="text-sm opacity-90">${this.formatDuration(block.duration)}</div>` : ''}
                    <button class="delete-bank-btn absolute top-1 right-1 w-6 h-6 bg-red-500 hover:bg-red-600 rounded-full text-white text-xs flex items-center justify-center">√ó</button>
                `;
                bankBlock.draggable = true;
                bankBlock.dataset.blockType = index;
                bankBlock.dataset.isPredefined = isPredefined.toString();
                bankBlock.addEventListener('dragstart', (e) => this.handleBankDragStart(e));
                bankBlock.addEventListener('dragend', (e) => this.handleDragEnd(e));
                
                // Touch events for mobile
                bankBlock.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                bankBlock.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                bankBlock.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                // Delete button event
                const deleteBtn = bankBlock.querySelector('.delete-bank-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.showDeleteConfirmation(index, isPredefined);
                });
                
                // Double-click to edit bank block
                bankBlock.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.editBankBlock(index, isPredefined);
                });
                
                return bankBlock;
            }
            
            setupEventListeners() {
                // Modal events
                document.getElementById('closeModal').addEventListener('click', () => this.closeModal());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveBlock());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteBlock());
                
                // Color selection
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectColor(e));
                });
                
                // New block creation
                document.getElementById('createBlockBtn').addEventListener('click', () => this.createCustomBlock());
                
                // New block color selection
                document.querySelectorAll('.new-color-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectNewColor(e));
                });
                
                // Emoji picker
                document.getElementById('emojiPickerBtn').addEventListener('click', (e) => this.toggleEmojiPicker(e));
                document.querySelectorAll('.emoji-option').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectEmoji(e));
                });
                
                // Delete confirmation modal
                document.getElementById('confirmDeleteBtn').addEventListener('click', () => this.confirmDeleteBlock());
                document.getElementById('cancelDeleteBtn').addEventListener('click', () => this.closeDeleteModal());
                
                // Clear grid functionality
                document.getElementById('clearGridBtn').addEventListener('click', () => this.showClearGridConfirmation());
                document.getElementById('confirmClearBtn').addEventListener('click', () => this.confirmClearGrid());
                document.getElementById('cancelClearBtn').addEventListener('click', () => this.closeClearGridModal());
                
                // Save snapshot functionality
                document.getElementById('saveWeekBtn').addEventListener('click', () => this.showSaveSnapshotModal());
                document.getElementById('confirmSaveBtn').addEventListener('click', () => this.saveSnapshot());
                document.getElementById('cancelSaveBtn').addEventListener('click', () => this.closeSaveSnapshotModal());
                document.getElementById('closeSaveModal').addEventListener('click', () => this.closeSaveSnapshotModal());
                
                // Load snapshot functionality
                document.getElementById('confirmLoadBtn').addEventListener('click', () => this.loadSnapshot());
                document.getElementById('cancelLoadBtn').addEventListener('click', () => this.closeLoadSnapshotModal());
                document.getElementById('closeLoadModal').addEventListener('click', () => this.closeLoadSnapshotModal());
                
                // Close modals on outside click
                document.getElementById('blockModal').addEventListener('click', (e) => {
                    if (e.target.id === 'blockModal') this.closeModal();
                });
                
                document.getElementById('deleteConfirmModal').addEventListener('click', (e) => {
                    if (e.target.id === 'deleteConfirmModal') this.closeDeleteModal();
                });
                
                document.getElementById('clearGridModal').addEventListener('click', (e) => {
                    if (e.target.id === 'clearGridModal') this.closeClearGridModal();
                });
                
                document.getElementById('saveSnapshotModal').addEventListener('click', (e) => {
                    if (e.target.id === 'saveSnapshotModal') this.closeSaveSnapshotModal();
                });
                
                document.getElementById('loadSnapshotModal').addEventListener('click', (e) => {
                    if (e.target.id === 'loadSnapshotModal') this.closeLoadSnapshotModal();
                });
                
                // Close emoji picker when clicking outside
                document.addEventListener('click', (e) => {
                    const picker = document.getElementById('emojiPicker');
                    const pickerBtn = document.getElementById('emojiPickerBtn');
                    if (!picker.contains(e.target) && !pickerBtn.contains(e.target)) {
                        picker.classList.add('hidden');
                    }
                });

                // Track last pointer position early (capture phase) for contextual toasts
                document.addEventListener('pointerdown', (e) => {
                    this.lastClickPosition = { x: e.clientX, y: e.clientY };
                }, true);

                // Open the native date picker when clicking/focusing the Monday date input
                const mondayInput = document.getElementById('mondayDate');
                if (mondayInput) {
                    const openPicker = (ev) => {
                        // Avoid immediate re-entrancy
                        setTimeout(() => {
                            if (typeof mondayInput.showPicker === 'function') {
                                try { mondayInput.showPicker(); } catch (_) { mondayInput.focus(); }
                            } else {
                                mondayInput.focus();
                            }
                        }, 0);
                    };
                    mondayInput.addEventListener('click', openPicker);
                    mondayInput.addEventListener('focus', openPicker);
                }

                // Memory Card: export/import
                const exportBtn = document.getElementById('exportMemoryBtn');
                const importBtn = document.getElementById('importMemoryBtn');
                const clearImportBtn = document.getElementById('clearImportBtn');
                if (exportBtn) exportBtn.addEventListener('click', () => this.exportMemoryCard());
                if (importBtn) importBtn.addEventListener('click', async () => {
                    const confirmed = await this.confirmModal('Isso vai substituir todos os dados atuais (grade, banco e capturas). Deseja continuar?', 'Importar', 'Cancelar');
                    if (confirmed) this.importMemoryCard();
                });
                if (clearImportBtn) clearImportBtn.addEventListener('click', () => this.clearImportField());

                // Memory Card: textarea guard (allow paste/copy/select, block typing/deleting)
                const importTextarea = document.getElementById('importTextarea');
                if (importTextarea) {
                    importTextarea.addEventListener('beforeinput', (e) => {
                        // Allow only paste insertions
                        if (e.inputType !== 'insertFromPaste') e.preventDefault();
                    });
                    importTextarea.addEventListener('drop', (e) => e.preventDefault());
                    importTextarea.addEventListener('keydown', (e) => {
                        const isShortcut = (e.ctrlKey || e.metaKey);
                        if (isShortcut) return; // allow Ctrl/Cmd+C/V/A
                        const nonEditingKeys = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown','Escape','F5','F6','F7','F8','F9','F10','F11','F12'];
                        if (nonEditingKeys.includes(e.key)) return;
                        const disallowed = ['Backspace','Delete','Enter','Tab'];
                        if (disallowed.includes(e.key) || (e.key && e.key.length === 1)) e.preventDefault();
                    });
                }

                // Todo tray functionality
                const todoTrayBtn = document.getElementById('todoTrayBtn');
                const todoTray = document.getElementById('todoTray');
                const closeTodoTray = document.getElementById('closeTodoTray');
                
                if (todoTrayBtn) {
                    todoTrayBtn.addEventListener('click', () => {
                        todoTray.classList.remove('translate-x-full');
                    });
                }
                
                if (closeTodoTray) {
                    closeTodoTray.addEventListener('click', () => {
                        todoTray.classList.add('translate-x-full');
                    });
                }
                
                // Close tray when clicking outside
                document.addEventListener('click', (e) => {
                    if (todoTray && !todoTray.classList.contains('translate-x-full')) {
                        // Check if click is outside the tray and not on the tray button
                        if (!todoTray.contains(e.target) && !todoTrayBtn.contains(e.target)) {
                            todoTray.classList.add('translate-x-full');
                        }
                    }
                });

                // Todo list event listeners
                const addTodoBtn = document.getElementById('addTodoBtn');
                const newTodoInput = document.getElementById('newTodoInput');
                
                if (addTodoBtn) {
                    addTodoBtn.addEventListener('click', () => this.addTodo());
                }
                
                if (newTodoInput) {
                    newTodoInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.addTodo();
                        }
                    });
                }

                // Info card functionality
                const infoBtn = document.getElementById('infoBtn');
                const infoCard = document.getElementById('infoCard');
                const infoBackdrop = document.getElementById('infoBackdrop');
                const closeInfoCard = document.getElementById('closeInfoCard');
                
                if (infoBtn && infoCard && infoBackdrop && closeInfoCard) {
                    const showInfoCard = () => {
                        infoBackdrop.classList.add('show');
                        infoCard.classList.add('show');
                    };
                    
                    const hideInfoCard = () => {
                        infoBackdrop.classList.remove('show');
                        infoCard.classList.remove('show');
                    };
                    
                    infoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showInfoCard();
                    });
                    
                    closeInfoCard.addEventListener('click', hideInfoCard);
                    
                    infoBackdrop.addEventListener('click', hideInfoCard);
                }

                // Memory Card info functionality
                const memoryInfoBtn = document.getElementById('memoryInfoBtn');
                const memoryInfoCard = document.getElementById('memoryInfoCard');
                const memoryInfoBackdrop = document.getElementById('memoryInfoBackdrop');
                const closeMemoryInfoCard = document.getElementById('closeMemoryInfoCard');
                
                if (memoryInfoBtn && memoryInfoCard && memoryInfoBackdrop && closeMemoryInfoCard) {
                    const showMemoryInfoCard = () => {
                        memoryInfoBackdrop.classList.add('show');
                        memoryInfoCard.classList.add('show');
                    };
                    
                    const hideMemoryInfoCard = () => {
                        memoryInfoBackdrop.classList.remove('show');
                        memoryInfoCard.classList.remove('show');
                    };
                    
                    memoryInfoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showMemoryInfoCard();
                    });
                    
                    closeMemoryInfoCard.addEventListener('click', hideMemoryInfoCard);
                    
                    memoryInfoBackdrop.addEventListener('click', hideMemoryInfoCard);
                }
            }
            
            handleBlockDragStart(e, block) {
                e.stopPropagation();
                const blockElement = e.target.closest('.time-block');
                if (!blockElement) return;

                // Remove dragging class from all blocks first
                document.querySelectorAll('.time-block').forEach(b => b.classList.remove('dragging'));
                
                // Set dragging visual state
                blockElement.classList.add('dragging');
                
                // Create a ghost image that matches the block's appearance
                const ghost = blockElement.cloneNode(true);
                ghost.style.transform = 'rotate(3deg)';
                ghost.style.opacity = '0.8';
                document.body.appendChild(ghost);
                e.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
                setTimeout(() => document.body.removeChild(ghost), 0);
                
                // If it's a block from the grid (has an ID), mark it as a move operation
                if (block.id) {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'move',
                        blockId: block.id,
                        name: block.name,
                        duration: block.duration,
                        color: block.color
                    }));
                    e.dataTransfer.effectAllowed = 'move';
                }
            }

            handleBankDragStart(e) {
                const blockType = parseInt(e.target.dataset.blockType);
                const isPredefined = e.target.dataset.isPredefined === 'true';
                let block;
                if (isPredefined) {
                    // Use filtered predefined blocks to get the correct block
                    const visiblePredefined = this.predefinedBlocks.filter(block => !this.removedPredefinedBlockNames.includes(block.name));
                    block = visiblePredefined[blockType];
                } else {
                    block = this.customBlocks[blockType];
                }
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    type: 'new',
                    name: block.name,
                    duration: block.duration,
                    color: block.color
                }));
                e.dataTransfer.effectAllowed = 'copy';
            }
            
            handleDragOver(e) {
                e.preventDefault();
                const cell = e.target.closest('.grid-cell');
                if (cell && cell.dataset.hour && cell.dataset.day) {
                    // Clear previous feedback
                    document.querySelectorAll('.grid-cell').forEach(c => {
                        if (c !== cell) c.style.backgroundColor = '';
                    });
                    
                    // Add visual feedback for valid drop zones
                    cell.style.backgroundColor = 'rgba(139, 92, 246, 0.2)';
                    
                    // Set dropEffect based on whether we're dragging from the grid or bank
                    const draggingBlock = document.querySelector('.time-block.dragging');
                    e.dataTransfer.dropEffect = draggingBlock ? 'move' : 'copy';
                    
                    // Auto-scroll when near edges
                    this.handleAutoScroll(e);
                }
            }
            
            handleAutoScroll(e) {
                const scrollThreshold = 100; // Distance from edge to trigger scroll
                const scrollSpeed = 5; // Pixels to scroll per frame
                const viewportHeight = window.innerHeight;
                const mouseY = e.clientY;
                
                // Scroll up when near top edge
                if (mouseY < scrollThreshold) {
                    window.scrollBy(0, -scrollSpeed);
                }
                // Scroll down when near bottom edge
                else if (mouseY > viewportHeight - scrollThreshold) {
                    window.scrollBy(0, scrollSpeed);
                }
            }
            
            handleDrop(e) {
                e.preventDefault();
                let data;
                try {
                    data = JSON.parse(e.dataTransfer.getData('text/plain'));
                } catch (err) {
                    console.error('Invalid drag data:', err);
                    return;
                }

                const cell = e.target.closest('.grid-cell');
                if (!cell || !cell.dataset.hour || !cell.dataset.day) {
                    console.log('Invalid drop target');
                    return;
                }
                
                // Clear visual feedback
                document.querySelectorAll('.grid-cell').forEach(c => {
                    c.style.backgroundColor = '';
                });
                
                const hour = parseInt(cell.dataset.hour);
                const day = parseInt(cell.dataset.day);
                // Determine desired half based on cursor position inside the cell
                const rect = cell.getBoundingClientRect();
                const relativeY = e.clientY - rect.top;
                const desiredStartHalf = relativeY >= rect.height / 2;
                
                if (data.type === 'new') {
                    this.createBlock({ ...data, startHalf: desiredStartHalf }, cell, desiredStartHalf);
                } else if (data.type === 'move') {
                    const block = this.blocks.find(b => b.id === data.blockId);
                    if (!block) {
                        console.log('Block not found:', data.blockId);
                        return;
                    }

                    // Don't do anything if dropped in the same position
                    if (block.hour === hour && block.day === day && !!block.startHalf === !!desiredStartHalf) {
                        return;
                    }
                    
                    // Check if the new position would cause overlap (half-hour aware)
                    const tempBlock = { ...block, hour, day, startHalf: desiredStartHalf };
                    if (!this.doesOverlapInHalfSlots(tempBlock, hour, day, desiredStartHalf)) {
                        console.log('Moving block to new position:', hour, day);
                        block.hour = hour;
                        block.day = day;
                        block.startHalf = desiredStartHalf;
                        this.renderBlocks();
                        this.saveBlocks();
                    } else {
                        // Try to find alternative position in half-hour grid
                        const alternativePosition = this.findAlternativeHalfPosition(tempBlock, hour, day, desiredStartHalf);
                        if (alternativePosition) {
                            console.log('Moving block to alternative position:', alternativePosition);
                            block.hour = alternativePosition.hour;
                            block.day = alternativePosition.day;
                            block.startHalf = alternativePosition.startHalf;
                            this.renderBlocks();
                            this.saveBlocks();
                        } else {
                            console.log('No valid position found for block');
                        }
                    }
                }
            }
            
            handleDragEnd(e) {
                // Remove dragging visual state from all elements
                document.querySelectorAll('.time-block, .bank-block').forEach(block => {
                    block.classList.remove('dragging');
                    block.style.transform = '';
                    block.style.opacity = '';
                });
                
                // Clear any drag-related visual states from cells
                document.querySelectorAll('.grid-cell').forEach(c => {
                    c.style.backgroundColor = '';
                });
            }
            
            handleCellClick(e) {
                const cell = e.target.closest('.grid-cell');
                if (cell && cell.dataset.hour && cell.dataset.day) {
                    // Check if there's a block in this cell
                    const block = this.findBlockInCell(cell);
                    if (block) {
                        this.openBlockModal(block);
                    }
                }
            }
            
            createBlock(data, cell, desiredStartHalfBool) {
                const hour = parseInt(cell.dataset.hour);
                const day = parseInt(cell.dataset.day);
                
                const desiredStartHalf = !!(data.startHalf ?? desiredStartHalfBool);
                // Check if position is available in half-hour grid
                const tempBlock = {
                    id: 'temp',
                    duration: data.duration,
                    hour: hour,
                    day: day,
                    startHalf: desiredStartHalf
                };
                
                if (!this.doesOverlapInHalfSlots(tempBlock, hour, day, desiredStartHalf)) {
                    const block = {
                        id: Date.now() + Math.random(),
                        name: data.name,
                        duration: data.duration,
                        color: data.color,
                        hour: hour,
                        day: day,
                        startHalf: desiredStartHalf
                    };
                    
                    this.blocks.push(block);
                    this.renderBlocks();
                    this.saveBlocks();
                } else {
                    // Try to find alternative position in half-hour grid
                    const alternativePosition = this.findAlternativeHalfPosition(tempBlock, hour, day, desiredStartHalf);
                    if (alternativePosition) {
                        const block = {
                            id: Date.now() + Math.random(),
                            name: data.name,
                            duration: data.duration,
                            color: data.color,
                            hour: alternativePosition.hour,
                            day: alternativePosition.day,
                            startHalf: alternativePosition.startHalf
                        };
                        
                        this.blocks.push(block);
                        this.renderBlocks();
                        this.saveBlocks();
                    }
                }
            }
            
            wouldBlockOverlap(block, hour, day) {
                // Backwards compatibility: delegate to half-slot aware check using startHalf (default false)
                const startHalf = !!block.startHalf;
                return this.doesOverlapInHalfSlots(block, hour, day, startHalf);
            }
            
            findAlternativePosition(block, preferredHour, preferredDay) {
                // Try to find an empty spot near the preferred position
                for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
                    const testDay = (preferredDay + dayOffset) % 7;
                    
                    for (let hourOffset = 0; hourOffset < 12; hourOffset++) {
                        const testHour = preferredHour + hourOffset;
                        if (testHour + block.duration > 24) break;
                        
                        if (!this.wouldBlockOverlap(block, testHour, testDay)) {
                            return { hour: testHour, day: testDay };
                        }
                    }
                }
                return null;
            }
            
            renderBlocks() {
                // Clear existing blocks
                document.querySelectorAll('.time-block').forEach(block => block.remove());
                
                // Group blocks by position to handle half-hour blocks
                const blocksByPosition = {};
                this.blocks.forEach(block => {
                    const key = `${block.hour}-${block.day}`;
                    if (!blocksByPosition[key]) {
                        blocksByPosition[key] = [];
                    }
                    blocksByPosition[key].push(block);
                });
                
                Object.keys(blocksByPosition).forEach(key => {
                    const [hour, day] = key.split('-');
                    const cell = document.querySelector(`[data-hour="${hour}"][data-day="${day}"]`);
                    if (cell) {
                        const blocksInCell = blocksByPosition[key];
                        
                        blocksInCell.forEach((block) => {
                            const blockElement = document.createElement('div');
                            const isHalfHour = block.duration === 0.5;
                            const heightClass = isHalfHour ? 'half-hour' : 'full-hour';
                            blockElement.className = `time-block bg-${block.color} text-white rounded-lg block-shadow ${heightClass}`;
                            
                            // Set height based on duration (60px per hour)
                            const blockHeight = block.duration * 60;
                            blockElement.style.height = `${blockHeight}px`;
                            
                            // Position blocks based on their start half
                            const startHalf = !!block.startHalf;
                            blockElement.style.top = startHalf ? '31px' : '0';
                            blockElement.style.left = '0';
                            blockElement.style.right = '0';
                            
                            blockElement.innerHTML = `
                                <div class="block-name">${block.name}</div>
                                ${block.duration !== 0.5 ? `<div class="block-duration">${this.formatDuration(block.duration)}</div>` : ''}
                            `;
                            blockElement.dataset.blockId = block.id;
                            
                            // Make block draggable
                            blockElement.draggable = true;
                            blockElement.addEventListener('dragstart', (e) => this.handleBlockDragStart(e, block));
                            blockElement.addEventListener('dragend', (e) => this.handleDragEnd(e));

                            blockElement.addEventListener('click', (e) => {
                                e.stopPropagation();
                                this.openBlockModal(block);
                            });
                            
                            cell.appendChild(blockElement);
                        });
                    }
                });
            }
            
            
            // Touch events for mobile drag and drop
            handleTouchStart(e) {
                this.touchStartY = e.touches[0].clientY;
                this.touchStartX = e.touches[0].clientX;
                this.isDragging = false;
                e.target.classList.add('dragging');
            }
            
            handleTouchMove(e) {
                if (!this.isDragging) {
                    const deltaY = Math.abs(e.touches[0].clientY - this.touchStartY);
                    const deltaX = Math.abs(e.touches[0].clientX - this.touchStartX);
                    
                    // Only consider it dragging if there's significant movement
                    if (deltaY > 10 || deltaX > 10) {
                        // Check if this is primarily a vertical scroll gesture
                        const isVerticalScroll = deltaY > deltaX * 1.5; // Vertical movement is 1.5x more than horizontal
                        
                        if (isVerticalScroll) {
                            // Allow natural scrolling, don't start drag
                            return;
                        }
                        
                        this.isDragging = true;
                    }
                }
                
                if (this.isDragging) {
                    e.preventDefault();
                    // Visual feedback for dragging
                    e.target.style.opacity = '0.8';
                    
                    // Auto-scroll for touch
                    this.handleTouchAutoScroll(e);
                }
            }
            
            handleTouchAutoScroll(e) {
                const scrollThreshold = 150; // Larger threshold for touch
                const scrollSpeed = 8; // Faster scroll for touch
                const viewportHeight = window.innerHeight;
                const touchY = e.touches[0].clientY;
                
                // Scroll up when near top edge
                if (touchY < scrollThreshold) {
                    window.scrollBy(0, -scrollSpeed);
                }
                // Scroll down when near bottom edge
                else if (touchY > viewportHeight - scrollThreshold) {
                    window.scrollBy(0, scrollSpeed);
                }
            }
            
            handleTouchEnd(e) {
                // Clear dragging state from all elements
                document.querySelectorAll('.time-block, .bank-block').forEach(block => {
                    block.classList.remove('dragging');
                    block.style.transform = '';
                    block.style.opacity = '';
                });
                
                // Clear any drag-related visual states from cells
                document.querySelectorAll('.grid-cell').forEach(c => {
                    c.style.backgroundColor = '';
                });
                
                if (this.isDragging) {
                    // Find the cell under the touch point
                    const touch = e.changedTouches[0];
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    const cell = elementBelow?.closest('.grid-cell');
                    
                    if (cell && cell.dataset.hour && cell.dataset.day) {
                        // Handle bank block drop
                        const blockType = parseInt(e.target.dataset.blockType);
                        if (blockType !== undefined) {
                            const isPredefined = e.target.dataset.isPredefined === 'true';
                            let block;
                            if (isPredefined) {
                                // Use filtered predefined blocks to get the correct block
                                const visiblePredefined = this.predefinedBlocks.filter(block => !this.removedPredefinedBlockNames.includes(block.name));
                                block = visiblePredefined[blockType];
                            } else {
                                block = this.customBlocks[blockType];
                            }
                            // Determine desired half based on touch position inside the cell
                            const rect = cell.getBoundingClientRect();
                            const desiredStartHalf = (touch.clientY - rect.top) >= rect.height / 2;
                            this.createBlock({
                                name: block.name,
                                duration: block.duration,
                                color: block.color,
                                startHalf: desiredStartHalf
                            }, cell, desiredStartHalf);
                        }
                    }
                }
                this.isDragging = false;
            }
            
            findBlockInCell(cell) {
                const blockElement = cell.querySelector('.time-block');
                if (blockElement) {
                    const blockId = blockElement.dataset.blockId;
                    return this.blocks.find(b => b.id === blockId);
                }
                return null;
            }
            
            openBlockModal(block) {
                this.currentBlock = block;
                document.getElementById('blockName').value = block.name;
                document.getElementById('blockDuration').value = block.duration;
                
                // Select current color
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.remove('border-white');
                    if (btn.dataset.color === block.color) {
                        btn.classList.add('border-white');
                    }
                });
                
                // Add real-time preview of duration changes
                const durationInput = document.getElementById('blockDuration');
                durationInput.addEventListener('input', (e) => {
                    const newDuration = parseFloat(e.target.value);
                    if (newDuration && newDuration > 0) {
                        // Visual feedback could be added here if needed
                        console.log(`Preview: ${newDuration}h duration`);
                    }
                });
                
                document.getElementById('blockModal').classList.remove('hidden');
            }
            
            closeModal() {
                document.getElementById('blockModal').classList.add('hidden');
                this.currentBlock = null;
                // Reset bank editing state
                this.isEditingBankBlock = false;
                this.editingBankBlockIndex = null;
                this.editingBankBlockIsPredefined = false;
            }
            
            selectColor(e) {
                document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('border-white'));
                e.target.classList.add('border-white');
            }
            
            saveBlock() {
                if (!this.currentBlock) return;
                
                // If editing a bank block, update it and re-render bank
                if (this.isEditingBankBlock) {
                    const nameInput = document.getElementById('blockName').value;
                    let durationInput = parseFloat(document.getElementById('blockDuration').value);
                    if (!nameInput || isNaN(durationInput) || durationInput < 0.5 || durationInput > 12) {
                    this.showToast('Preencha um nome e uma dura√ß√£o entre 0.5 e 12 horas.', 'error');
                        return;
                    }
                    // Enforce 30-minute increments
                    const rounded = this.roundToHalf(durationInput);
                    if (!this.isHalfHourMultiple(durationInput)) {
                        this.showToast(`Dura√ß√£o ajustada para ${rounded}h (m√∫ltiplos de 0.5h).`, 'info');
                    }
                    durationInput = rounded;
                    this.currentBlock.name = nameInput;
                    this.currentBlock.duration = durationInput;
                    const selectedColor = document.querySelector('.color-btn.border-white');
                    if (selectedColor) {
                        this.currentBlock.color = selectedColor.dataset.color;
                    }
                    
                    // If editing a predefined block, save the modifications
                    if (this.editingBankBlockIsPredefined) {
                        this.savePredefinedBlockModification(this.currentBlock);
                    } else {
                        this.saveCustomBlocks();
                    }
                    
                    this.createBlockBank();
                    this.closeModal();
                    return;
                }
                
                const oldDuration = this.currentBlock.duration;
                this.currentBlock.name = document.getElementById('blockName').value;
                let newDuration = parseFloat(document.getElementById('blockDuration').value);
                if (isNaN(newDuration) || newDuration < 0.5 || newDuration > 12) {
                    this.showToast('A dura√ß√£o deve estar entre 0.5 e 12 horas.', 'error');
                    return;
                }
                const roundedGrid = this.roundToHalf(newDuration);
                if (!this.isHalfHourMultiple(newDuration)) {
                    this.showToast(`Dura√ß√£o ajustada para ${roundedGrid}h (m√∫ltiplos de 0.5h).`, 'info');
                }
                this.currentBlock.duration = roundedGrid;
                
                const selectedColor = document.querySelector('.color-btn.border-white');
                if (selectedColor) {
                    this.currentBlock.color = selectedColor.dataset.color;
                }
                
                // Check if the new duration would cause overlap (half-hour aware)
                const wouldOverlap = this.doesOverlapInHalfSlots(this.currentBlock, this.currentBlock.hour, this.currentBlock.day, !!this.currentBlock.startHalf);
                
                if (wouldOverlap) {
                    // If overlapping, try to find alternative position
                    const alternativePosition = this.findAlternativeHalfPosition(this.currentBlock, this.currentBlock.hour, this.currentBlock.day, !!this.currentBlock.startHalf);
                    if (alternativePosition) {
                        this.currentBlock.hour = alternativePosition.hour;
                        this.currentBlock.day = alternativePosition.day;
                        this.currentBlock.startHalf = alternativePosition.startHalf;
                    } else {
                        // If no alternative position found, revert duration
                        this.currentBlock.duration = oldDuration;
                        this.showToast('N√£o √© poss√≠vel alterar a dura√ß√£o para este valor (sobreposi√ß√£o).', 'error');
                        this.renderBlocks();
                        this.saveBlocks();
                        this.closeModal();
                        return;
                    }
                }
                
                this.renderBlocks();
                this.saveBlocks();
                this.closeModal();
            }
            
            
            deleteBlock() {
                // If deleting from the bank editor modal, show the same confirmation used by the bank 'x' button
                if (this.isEditingBankBlock) {
                    const index = this.editingBankBlockIndex;
                    const isPredefined = this.editingBankBlockIsPredefined;
                    // Close the edit modal before showing confirmation to avoid overlapping modals
                    this.closeModal();
                    this.showDeleteConfirmation(index, isPredefined);
                    return;
                }
                
                // Otherwise, deleting a placed block from the grid
                if (!this.currentBlock) return;
                this.blocks = this.blocks.filter(b => b.id !== this.currentBlock.id);
                this.renderBlocks();
                this.saveBlocks();
                this.closeModal();
            }
            
            saveBlocks() {
                localStorage.setItem('weeklyPlannerBlocks', JSON.stringify(this.blocks));
            }
            
            loadBlocks() {
                const saved = localStorage.getItem('weeklyPlannerBlocks');
                if (saved) {
                    this.blocks = JSON.parse(saved).map(b => ({ ...b, startHalf: !!b.startHalf }));
                    this.renderBlocks();
                }
            }
            
            loadCustomBlocks() {
                const saved = localStorage.getItem('weeklyPlannerCustomBlocks');
                if (saved) {
                    this.customBlocks = JSON.parse(saved);
                    this.createBlockBank();
                }
            }
            
            saveCustomBlocks() {
                localStorage.setItem('weeklyPlannerCustomBlocks', JSON.stringify(this.customBlocks));
            }
            
            createCustomBlock() {
                const emoji = this.selectedEmoji;
                const name = document.getElementById('newBlockName').value.trim();
                let duration = parseFloat(document.getElementById('newBlockDuration').value);
                
                if (!name) {
                    this.showToast('Por favor, insira um nome para o bloco.', 'error');
                    return;
                }
                
                if (duration < 0.5 || duration > 12) {
                    this.showToast('A dura√ß√£o deve estar entre 0.5 e 12 horas.', 'error');
                    return;
                }
                // Enforce 30-minute increments
                const rounded = this.roundToHalf(duration);
                if (!this.isHalfHourMultiple(duration)) {
                    this.showToast(`Dura√ß√£o ajustada para ${rounded}h (m√∫ltiplos de 0.5h).`, 'info');
                }
                duration = rounded;
                
                const newBlock = {
                    name: `${emoji} ${name}`,
                    duration: duration,
                    color: this.selectedNewColor
                };
                
                this.customBlocks.push(newBlock);
                this.createBlockBank();
                this.saveCustomBlocks();
                
                // Clear form
                document.getElementById('newBlockName').value = '';
                document.getElementById('newBlockDuration').value = '1';
                this.selectedEmoji = 'üéØ';
                document.getElementById('selectedEmoji').textContent = 'üéØ';
            }
            
            setDefaultColor() {
                // Set the default color visually (purple-500)
                document.querySelectorAll('.new-color-btn').forEach(btn => {
                    btn.classList.remove('border-white');
                    if (btn.dataset.color === this.selectedNewColor) {
                        btn.classList.add('border-white');
                    }
                });
            }
            
            selectNewColor(e) {
                document.querySelectorAll('.new-color-btn').forEach(btn => btn.classList.remove('border-white'));
                e.target.classList.add('border-white');
                this.selectedNewColor = e.target.dataset.color;
            }
            
            toggleEmojiPicker(e) {
                e.stopPropagation();
                const picker = document.getElementById('emojiPicker');
                const button = e.target.closest('button');
                
                if (picker.classList.contains('hidden')) {
                    // Position the picker relative to the button
                    const buttonRect = button.getBoundingClientRect();
                    picker.style.position = 'fixed';
                    picker.style.top = (buttonRect.bottom + 8) + 'px';
                    picker.style.left = buttonRect.left + 'px';
                    picker.style.zIndex = '9999';
                }
                
                picker.classList.toggle('hidden');
            }
            
            selectEmoji(e) {
                e.stopPropagation();
                const emoji = e.target.dataset.emoji;
                this.selectedEmoji = emoji;
                document.getElementById('selectedEmoji').textContent = emoji;
                document.getElementById('emojiPicker').classList.add('hidden');
            }
            
            showDeleteConfirmation(blockIndex, isPredefined) {
                this.blockToDelete = blockIndex;
                this.blockToDeleteIsPredefined = isPredefined;
                document.getElementById('deleteConfirmModal').classList.remove('hidden');
            }
            
            closeDeleteModal() {
                document.getElementById('deleteConfirmModal').classList.add('hidden');
                this.blockToDelete = null;
                this.blockToDeleteIsPredefined = false;
            }
            
            confirmDeleteBlock() {
                if (this.blockToDelete !== null) {
                    if (this.blockToDeleteIsPredefined) {
                        // Determine the actual block considering filtered view
                        const visiblePredefined = this.predefinedBlocks.filter(block => !this.removedPredefinedBlockNames.includes(block.name));
                        const block = visiblePredefined[this.blockToDelete];
                        if (block) {
                            // Persist removal across sessions
                            if (!this.removedPredefinedBlockNames.includes(block.name)) {
                                this.removedPredefinedBlockNames.push(block.name);
                                this.saveRemovedPredefinedBlocks();
                            }
                        }
                    } else {
                        this.customBlocks.splice(this.blockToDelete, 1);
                        this.saveCustomBlocks();
                    }
                    this.createBlockBank();
                    this.closeDeleteModal();
                }
            }

            saveRemovedPredefinedBlocks() {
                localStorage.setItem('weeklyPlannerRemovedPredefined', JSON.stringify(this.removedPredefinedBlockNames));
            }
            
            loadRemovedPredefinedBlocks() {
                const saved = localStorage.getItem('weeklyPlannerRemovedPredefined');
                if (saved) {
                    try {
                        this.removedPredefinedBlockNames = JSON.parse(saved) || [];
                    } catch (_) {
                        this.removedPredefinedBlockNames = [];
                    }
                }
            }

            loadPredefinedBlockModifications() {
                const saved = localStorage.getItem('weeklyPlannerPredefinedModifications');
                if (saved) {
                    try {
                        this.predefinedBlockModifications = JSON.parse(saved) || {};
                    } catch (_) {
                        this.predefinedBlockModifications = {};
                    }
                }
            }

            savePredefinedBlockModifications() {
                localStorage.setItem('weeklyPlannerPredefinedModifications', JSON.stringify(this.predefinedBlockModifications));
            }

            getModifiedPredefinedBlock(originalBlock) {
                // Check if there are modifications for this block
                const modifications = this.predefinedBlockModifications[originalBlock.name];
                if (modifications) {
                    // Return a copy of the original block with modifications applied
                    return {
                        ...originalBlock,
                        ...modifications
                    };
                }
                return originalBlock;
            }

            savePredefinedBlockModification(modifiedBlock) {
                // Get the original block from the predefined blocks array using the index
                const originalBlock = this.predefinedBlocks[this.editingBankBlockIndex];
                
                if (originalBlock) {
                    // Store the modifications using the original block name as key
                    this.predefinedBlockModifications[originalBlock.name] = {
                        name: modifiedBlock.name,
                        duration: modifiedBlock.duration,
                        color: modifiedBlock.color
                    };
                    this.savePredefinedBlockModifications();
                }
            }

            editBankBlock(blockIndex, isPredefined) {
                this.isEditingBankBlock = true;
                this.editingBankBlockIndex = blockIndex;
                this.editingBankBlockIsPredefined = isPredefined;
                
                let block;
                if (isPredefined) {
                    // Get the modified version of the predefined block
                    const originalBlock = this.predefinedBlocks[blockIndex];
                    block = this.getModifiedPredefinedBlock(originalBlock);
                } else {
                    block = this.customBlocks[blockIndex];
                }
                
                this.openBlockModal(block);
            }
            
            showClearGridConfirmation() {
                document.getElementById('clearGridModal').classList.remove('hidden');
            }
            
            closeClearGridModal() {
                document.getElementById('clearGridModal').classList.add('hidden');
            }
            
            confirmClearGrid() {
                // Clear all blocks from the grid
                this.blocks = [];
                this.renderBlocks();
                this.saveBlocks();
                this.closeClearGridModal();
                
                // Show success message
                this.showToast('Grade limpa com sucesso! Todos os blocos foram removidos.', 'success');
            }
            
            // Snapshot functionality
            showSaveSnapshotModal() {
                // Set default date to current Monday
                const today = new Date();
                const dayOfWeek = today.getDay();
                const monday = new Date(today);
                monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
                
                const mondayDateInput = document.getElementById('mondayDate');
                // Format date as YYYY-MM-DD without timezone issues
                const year = monday.getFullYear();
                const month = String(monday.getMonth() + 1).padStart(2, '0');
                const day = String(monday.getDate()).padStart(2, '0');
                mondayDateInput.value = `${year}-${month}-${day}`;
                
                document.getElementById('saveSnapshotModal').classList.remove('hidden');
            }
            
            closeSaveSnapshotModal() {
                document.getElementById('saveSnapshotModal').classList.add('hidden');
            }
            
            saveSnapshot() {
                const mondayDate = document.getElementById('mondayDate').value;
                if (!mondayDate) {
                    alert('Por favor, selecione uma data para a segunda-feira.');
                    return;
                }
                
                // Parse the date correctly to avoid timezone issues
                const [year, month, day] = mondayDate.split('-').map(Number);
                const mondayDateObj = new Date(year, month - 1, day); // month is 0-indexed
                const sundayDateObj = new Date(mondayDateObj);
                sundayDateObj.setDate(mondayDateObj.getDate() + 6); // Add 6 days to get Sunday
                
                const mondayFormatted = mondayDateObj.toLocaleDateString('pt-BR', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: '2-digit' 
                });
                const sundayFormatted = sundayDateObj.toLocaleDateString('pt-BR', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: '2-digit' 
                });
                
                const snapshot = {
                    id: Date.now() + Math.random(),
                    name: `Semana ${mondayFormatted} - ${sundayFormatted}`,
                    mondayDate: mondayDate,
                    description: (document.getElementById('snapshotDescription').value || '').trim(),
                    blocks: JSON.parse(JSON.stringify(this.blocks)), // Deep copy
                    thumbnail: this.generateGridThumbnail(),
                    createdAt: new Date().toISOString(),
                    weekComments: ''
                };
                
                this.snapshots.push(snapshot);
                this.saveSnapshots();
                this.renderSnapshots();
                this.closeSaveSnapshotModal();
                
                // Clear description input for next time
                const descInput = document.getElementById('snapshotDescription');
                if (descInput) descInput.value = '';

                this.showToast(`Captura "${snapshot.name}" salva com sucesso!`, 'success');
            }
            
            generateGridThumbnail() {
                // Create a simplified representation of the grid
                const thumbnail = {
                    blocks: this.blocks.map(block => ({
                        hour: block.hour,
                        day: block.day,
                        duration: block.duration,
                        color: block.color,
                        name: block.name
                    }))
                };
                return thumbnail;
            }
            
            renderSnapshots() {
                const snapshotsGrid = document.getElementById('snapshotsGrid');
                const noSnapshotsMessage = document.getElementById('noSnapshotsMessage');
                
                if (this.snapshots.length === 0) {
                    snapshotsGrid.innerHTML = '';
                    noSnapshotsMessage.classList.remove('hidden');
                    return;
                }
                
                noSnapshotsMessage.classList.add('hidden');
                snapshotsGrid.innerHTML = '';
                
                // Sort snapshots by creation date (newest first)
                const sortedSnapshots = [...this.snapshots].sort((a, b) => 
                    new Date(b.createdAt) - new Date(a.createdAt)
                );
                
                sortedSnapshots.forEach(snapshot => {
                    const snapshotCard = this.createSnapshotCard(snapshot);
                    snapshotsGrid.appendChild(snapshotCard);
                });
            }
            
            createSnapshotCard(snapshot) {
                const card = document.createElement('div');
                card.className = 'snapshot-card';
                card.dataset.snapshotId = snapshot.id;
                
                card.innerHTML = `
                    <div class="snapshot-thumbnail">
                        <div class="snapshot-thumbnail-grid">
                            ${this.createThumbnailGrid(snapshot.thumbnail)}
                        </div>
                    </div>
                    <div class="snapshot-info">
                        <div class="snapshot-name">${snapshot.name}</div>
                        ${snapshot.description ? `<div class=\"text-xs text-dark-muted\">${snapshot.description}</div>` : ''}
                    </div>
                    <button class="snapshot-delete-btn" data-snapshot-id="${snapshot.id}">√ó</button>
                `;
                
                // Add blocks to the thumbnail after the card is created
                this.populateThumbnailBlocks(card, snapshot.thumbnail);
                
                // Add click event to load snapshot
                card.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('snapshot-delete-btn')) {
                        this.showLoadSnapshotModal(snapshot);
                    }
                });
                
                // Add delete button event
                const deleteBtn = card.querySelector('.snapshot-delete-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteSnapshot(snapshot.id);
                });
                
                return card;
            }
            
            createThumbnailGrid(thumbnail) {
                let gridHTML = '';
                
                // Create 7 days x 18 hours grid (6-23 + 0)
                for (let hour = 6; hour <= 23; hour++) {
                    for (let day = 0; day < 7; day++) {
                        gridHTML += `<div class="snapshot-thumbnail-cell" data-hour="${hour}" data-day="${day}"></div>`;
                    }
                }
                // Add hour 0 (midnight)
                for (let day = 0; day < 7; day++) {
                    gridHTML += `<div class="snapshot-thumbnail-cell" data-hour="0" data-day="${day}"></div>`;
                }
                
                return gridHTML;
            }
            
            populateThumbnailBlocks(card, thumbnail) {
                if (!thumbnail.blocks) return;
                
                const grid = card.querySelector('.snapshot-thumbnail-grid');
                
                thumbnail.blocks.forEach(block => {
                    // Find the starting cell
                    const startCell = grid.querySelector(`[data-hour="${block.hour}"][data-day="${block.day}"]`);
                    if (!startCell) return;
                    
                    // Calculate how many cells this block should span
                    const durationInHalfHours = block.duration * 2; // Convert hours to half-hour units
                    const cellsToSpan = Math.ceil(durationInHalfHours);
                    
                    // Create the block element
                    const blockElement = document.createElement('div');
                    blockElement.className = 'snapshot-thumbnail-block';
                    blockElement.style.backgroundColor = this.getColorValue(block.color);
                    blockElement.style.height = `${Math.max(block.duration * 7, 3)}px`; // 7px per 0.5 hour, minimum 3px
                    blockElement.title = block.name;
                    blockElement.style.fontSize = '4px';
                    blockElement.style.padding = '1px';
                    blockElement.style.boxSizing = 'border-box';
                    blockElement.style.position = 'absolute';
                    blockElement.style.left = '0';
                    blockElement.style.right = '0';
                    blockElement.style.top = '0';
                    blockElement.style.zIndex = '10';
                    
                    // For multi-hour blocks, we need to span across multiple cells
                    if (block.duration > 1) {
                        // Find all cells that this block should cover
                        const cellsToCover = [];
                        let currentHour = block.hour;
                        let remainingDuration = block.duration;
                        
                        while (remainingDuration > 0 && currentHour <= 23) {
                            const cell = grid.querySelector(`[data-hour="${currentHour}"][data-day="${block.day}"]`);
                            if (cell) {
                                cellsToCover.push(cell);
                            }
                            currentHour++;
                            remainingDuration--;
                        }
                        
                        // If the block goes past midnight (hour 0)
                        if (remainingDuration > 0) {
                            const cell = grid.querySelector(`[data-hour="0"][data-day="${block.day}"]`);
                            if (cell) {
                                cellsToCover.push(cell);
                            }
                        }
                        
                        // Place the block in the first cell and make it span the full height
                        if (cellsToCover.length > 0) {
                            const firstCell = cellsToCover[0];
                            firstCell.style.position = 'relative';
                            firstCell.appendChild(blockElement);
                            
                            // Make the block span the full height of all covered cells
                            const totalHeight = cellsToCover.length * 7; // 7px per cell
                            blockElement.style.height = `${Math.max(totalHeight, 3)}px`;
                        }
                    } else {
                        // For single hour or half-hour blocks, place normally
                        startCell.style.position = 'relative';
                        startCell.appendChild(blockElement);
                    }
                });
            }
            
            getColorValue(colorClass) {
                // Convert Tailwind color classes to actual color values
                const colorMap = {
                    'red-500': '#ef4444',
                        'red-400': '#f87171',
                        'red-600': '#dc2626',
                        'blue-500': '#3b82f6',
                        'blue-700': '#1d4ed8',
                    'green-500': '#10b981',
                        'green-700': '#047857',
                    'yellow-500': '#eab308',
                    'gray-500': '#6b7280',
                    'purple-500': '#8b5cf6',
                    'pink-500': '#ec4899',
                    'orange-500': '#f59e0b',
                        'orange-400': '#fb923c',
                        'orange-600': '#ea580c',
                    'cyan-500': '#06b6d4',
                    'indigo-500': '#6366f1',
                    'rose-500': '#f43f5e',
                    'teal-500': '#14b8a6',
                    'lime-500': '#84cc16',
                    'amber-500': '#f59e0b',
                    'violet-500': '#8b5cf6',
                    'sky-400': '#38bdf8',
                    'game-purple': '#8B5CF6',
                    'game-blue': '#3B82F6',
                    'game-green': '#10B981',
                    'game-orange': '#F59E0B',
                    'game-red': '#EF4444',
                    'game-pink': '#EC4899',
                    'game-cyan': '#06B6D4'
                };
                return colorMap[colorClass] || '#8b5cf6';
            }
            
            showLoadSnapshotModal(snapshot) {
                this.selectedSnapshot = snapshot;
                document.getElementById('selectedSnapshotName').textContent = snapshot.name;
                // Populate comments
                const commentsEl = document.getElementById('snapshotWeekComments');
                if (commentsEl) commentsEl.value = snapshot.weekComments || '';
                // Populate optional custom name/description
                const descWrapper = document.getElementById('selectedSnapshotDescriptionWrapper');
                const descEl = document.getElementById('selectedSnapshotDescription');
                if (descWrapper && descEl) {
                    const hasDesc = (snapshot.description || '').trim().length > 0;
                    if (hasDesc) {
                        descEl.textContent = snapshot.description;
                        descWrapper.classList.remove('hidden');
                    } else {
                        descEl.textContent = '';
                        descWrapper.classList.add('hidden');
                    }
                }
                document.getElementById('loadSnapshotModal').classList.remove('hidden');
            }
            
            closeLoadSnapshotModal() {
                // Auto-save comments (if any snapshot is selected)
                const commentsEl = document.getElementById('snapshotWeekComments');
                if (this.selectedSnapshot && commentsEl) {
                    this.selectedSnapshot.weekComments = commentsEl.value || '';
                    // Persist back to array and storage
                    const idx = this.snapshots.findIndex(s => s.id === this.selectedSnapshot.id);
                    if (idx !== -1) {
                        this.snapshots[idx] = { ...this.snapshots[idx], weekComments: this.selectedSnapshot.weekComments };
                        this.saveSnapshots();
                    }
                }
                document.getElementById('loadSnapshotModal').classList.add('hidden');
                this.selectedSnapshot = null;
            }
            
            loadSnapshot() {
                if (!this.selectedSnapshot) return;
                
                // Load the snapshot blocks
                this.blocks = JSON.parse(JSON.stringify(this.selectedSnapshot.blocks));
                this.renderBlocks();
                this.saveBlocks();
                this.closeLoadSnapshotModal();
                
                this.showToast(`Captura "${this.selectedSnapshot.name}" carregada com sucesso!`, 'success');
            }
            
            deleteSnapshot(snapshotId) {
                this.confirmModal('Tem certeza que deseja excluir esta captura? Esta a√ß√£o n√£o pode ser desfeita.', 'Excluir', 'Cancelar', 'danger')
                    .then(confirmed => {
                        if (confirmed) {
                            this.snapshots = this.snapshots.filter(s => s.id !== snapshotId);
                            this.saveSnapshots();
                            this.renderSnapshots();
                            this.showToast('Captura exclu√≠da.', 'success');
                        }
                    });
            }
            
            saveSnapshots() {
                localStorage.setItem('weeklyPlannerSnapshots', JSON.stringify(this.snapshots));
            }
            
            loadSnapshots() {
                const saved = localStorage.getItem('weeklyPlannerSnapshots');
                if (saved) {
                    this.snapshots = JSON.parse(saved).map(s => ({ ...s, weekComments: s.weekComments || '' }));
                }
            }

            // ===== Memory Card (Export/Import Full State) =====
            populateExportField() {
                try {
                    const payload = {
                        version: 1,
                        exportedAt: new Date().toISOString(),
                        blocks: (this.blocks || []).map(b => ({ ...b, startHalf: !!b.startHalf })),
                        customBlocks: this.customBlocks || [],
                        predefinedBlockModifications: this.predefinedBlockModifications || {},
                        removedPredefinedBlockNames: this.removedPredefinedBlockNames || [],
                        snapshots: (this.snapshots || []).map(s => ({
                            ...s,
                            blocks: (s.blocks || []).map(b => ({ ...b, startHalf: !!b.startHalf }))
                        })),
                        todos: this.todos || []
                    };
                    const exportTextarea = document.getElementById('exportTextarea');
                    if (exportTextarea) {
                        exportTextarea.value = JSON.stringify(payload);
                    }
                } catch (err) {
                    console.error('Error populating export field:', err);
                }
            }

            exportMemoryCard() {
                try {
                    // Refresh the export field with current data
                    this.populateExportField();
                    
                    const exportTextarea = document.getElementById('exportTextarea');
                    if (exportTextarea) {
                        exportTextarea.focus();
                        exportTextarea.select();
                        try {
                            document.execCommand('copy');
                            this.showToast('Dados compactos exportados para a √°rea de transfer√™ncia.', 'success');
                        } catch (_) {
                            this.showToast('Exportado. Copie o texto manualmente se desejar.', 'info');
                        }
                        
                        // Auto-close the Memory Card section with animation
                        const memoryCardContent = document.getElementById('memoryCardContent');
                        const memoryCardToggleIcon = document.getElementById('memoryCardToggleIcon');
                        if (memoryCardContent && memoryCardToggleIcon) {
                            setTimeout(() => {
                                this.toggleMinimize('memoryCard', memoryCardContent, memoryCardToggleIcon);
                            }, 500); // Small delay to show the success message
                        }
                    } else {
                        this.showToast('√Årea de texto de exporta√ß√£o n√£o encontrada.', 'error');
                    }
                } catch (err) {
                    console.error(err);
                    this.showToast('Falha ao exportar dados.', 'error');
                }
            }

            importMemoryCard() {
                const importTextarea = document.getElementById('importTextarea');
                if (!importTextarea) {
                    this.showToast('√Årea de texto de importa√ß√£o n√£o encontrada.', 'error');
                    return;
                }
                let data;
                try {
                    data = JSON.parse(importTextarea.value);
                } catch (err) {
                    this.showToast('JSON inv√°lido. Verifique o conte√∫do e tente novamente.', 'error');
                    return;
                }
                try {
                    // Basic validation and normalization
                    const importedBlocks = Array.isArray(data.blocks) ? data.blocks.map(b => ({ ...b, startHalf: !!b.startHalf })) : [];
                    const importedCustom = Array.isArray(data.customBlocks) ? data.customBlocks : [];
                    const importedMods = data.predefinedBlockModifications && typeof data.predefinedBlockModifications === 'object' ? data.predefinedBlockModifications : {};
                    const importedRemoved = Array.isArray(data.removedPredefinedBlockNames) ? data.removedPredefinedBlockNames : [];
                    const importedSnapshots = Array.isArray(data.snapshots) ? data.snapshots.map(s => ({
                        ...s,
                        blocks: Array.isArray(s.blocks) ? s.blocks.map(b => ({ ...b, startHalf: !!b.startHalf })) : []
                    })) : [];
                    const importedTodos = Array.isArray(data.todos) ? data.todos : [];

                    // Assign in-memory state
                    this.blocks = importedBlocks;
                    this.customBlocks = importedCustom;
                    this.predefinedBlockModifications = importedMods;
                    this.removedPredefinedBlockNames = importedRemoved;
                    this.snapshots = importedSnapshots;
                    this.todos = importedTodos;

                    // Persist to storage
                    this.saveBlocks();
                    this.saveCustomBlocks();
                    this.savePredefinedBlockModifications();
                    this.saveRemovedPredefinedBlocks();
                    this.saveSnapshots();
                    this.saveTodos();

                    // Re-render UI
                    this.createBlockBank();
                    this.renderBlocks();
                    this.renderSnapshots();
                    this.renderTodos();
                    this.showToast('Importa√ß√£o conclu√≠da com sucesso!', 'success');
                    
                    // Auto-close the Memory Card section with animation
                    const memoryCardContent = document.getElementById('memoryCardContent');
                    const memoryCardToggleIcon = document.getElementById('memoryCardToggleIcon');
                    if (memoryCardContent && memoryCardToggleIcon) {
                        setTimeout(() => {
                            this.toggleMinimize('memoryCard', memoryCardContent, memoryCardToggleIcon);
                        }, 500); // Small delay to show the success message
                    }
                } catch (err) {
                    console.error(err);
                    this.showToast('Falha ao importar dados.', 'error');
                }
            }

            clearImportField() {
                const importTextarea = document.getElementById('importTextarea');
                if (importTextarea) {
                    importTextarea.value = '';
                    importTextarea.focus();
                    this.showToast('√Årea de importa√ß√£o limpa.', 'info');
                }
            }

            // ===== Todo List Methods =====
            addTodo() {
                const input = document.getElementById('newTodoInput');
                const text = input.value.trim();
                
                if (!text) {
                    this.showToast('Por favor, digite uma tarefa.', 'error');
                    return;
                }
                
                const todo = {
                    id: Date.now() + Math.random(),
                    text: text,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                this.todos.push(todo);
                this.saveTodos();
                this.renderTodos();
                
                // Clear input
                input.value = '';
                input.focus();
                
                this.showToast('Tarefa adicionada!', 'success');
            }
            
            toggleTodo(todoId) {
                const todo = this.todos.find(t => t.id === todoId);
                if (todo) {
                    todo.completed = !todo.completed;
                    this.saveTodos();
                    this.renderTodos();
                }
            }
            
            deleteTodo(todoId) {
                this.todos = this.todos.filter(t => t.id !== todoId);
                this.saveTodos();
                this.renderTodos();
                this.showToast('Tarefa removida.', 'info');
            }
            
            startEditTodo(todoId) {
                this.editingTodoId = todoId;
                this.renderTodos();
                
                // Focus the input after a short delay to ensure it's rendered
                setTimeout(() => {
                    const input = document.querySelector(`[data-todo-id="${todoId}"] .todo-edit-input`);
                    if (input) {
                        input.focus();
                        input.select();
                    }
                }, 10);
            }
            
            saveEditTodo(todoId, newText) {
                const todo = this.todos.find(t => t.id === todoId);
                if (todo && newText.trim()) {
                    todo.text = newText.trim();
                    this.saveTodos();
                    this.renderTodos();
                    this.showToast('Tarefa atualizada!', 'success');
                } else if (todo && !newText.trim()) {
                    // If empty text, delete the todo
                    this.deleteTodo(todoId);
                }
                this.editingTodoId = null;
            }
            
            cancelEditTodo() {
                this.editingTodoId = null;
                this.renderTodos();
            }
            
            renderTodos() {
                const todoList = document.getElementById('todoList');
                const noTodosMessage = document.getElementById('noTodosMessage');
                
                if (!todoList) return;
                
                if (this.todos.length === 0) {
                    todoList.innerHTML = '';
                    noTodosMessage.classList.remove('hidden');
                    return;
                }
                
                noTodosMessage.classList.add('hidden');
                todoList.innerHTML = '';
                
                // Sort todos: incomplete first, then by creation date
                const sortedTodos = [...this.todos].sort((a, b) => {
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1;
                    }
                    return new Date(a.createdAt) - new Date(b.createdAt);
                });
                
                sortedTodos.forEach(todo => {
                    const todoElement = this.createTodoElement(todo);
                    todoList.appendChild(todoElement);
                });
            }
            
            createTodoElement(todo) {
                const todoDiv = document.createElement('div');
                todoDiv.className = 'todo-item';
                todoDiv.dataset.todoId = todo.id;
                
                if (this.editingTodoId === todo.id) {
                    // Edit mode
                    todoDiv.innerHTML = `
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}"></div>
                        <input type="text" class="todo-edit-input" value="${this.escapeHtml(todo.text)}">
                        <button class="todo-delete-btn">√ó</button>
                    `;
                    
                    // Add event listeners for edit mode
                    const checkbox = todoDiv.querySelector('.todo-checkbox');
                    const input = todoDiv.querySelector('.todo-edit-input');
                    const deleteBtn = todoDiv.querySelector('.todo-delete-btn');
                    
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleTodo(todo.id);
                    });
                    
                    input.addEventListener('blur', () => {
                        this.saveEditTodo(todo.id, input.value);
                    });
                    
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.saveEditTodo(todo.id, input.value);
                        }
                    });
                    
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            this.cancelEditTodo();
                        }
                    });
                    
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteTodo(todo.id);
                    });
                } else {
                    // Normal mode
                    todoDiv.innerHTML = `
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}"></div>
                        <div class="todo-text ${todo.completed ? 'completed' : ''}">${this.escapeHtml(todo.text)}</div>
                        <button class="todo-delete-btn">√ó</button>
                    `;
                    
                    // Add event listeners for normal mode
                    const checkbox = todoDiv.querySelector('.todo-checkbox');
                    const text = todoDiv.querySelector('.todo-text');
                    const deleteBtn = todoDiv.querySelector('.todo-delete-btn');
                    
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.toggleTodo(todo.id);
                    });
                    
                    text.addEventListener('dblclick', () => {
                        this.startEditTodo(todo.id);
                    });
                    
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteTodo(todo.id);
                    });
                }
                
                return todoDiv;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            formatDuration(duration) {
                if (duration === 0.5) return '30m';
                if (duration === 1) return '1h';
                if (duration === 1.5) return '1h30m';
                if (duration === 2) return '2h';
                if (duration === 2.5) return '2h30m';
                if (duration === 3) return '3h';
                if (duration === 3.5) return '3h30m';
                if (duration === 4) return '4h';
                if (duration === 4.5) return '4h30m';
                if (duration === 5) return '5h';
                if (duration === 5.5) return '5h30m';
                if (duration === 6) return '6h';
                if (duration === 6.5) return '6h30m';
                if (duration === 7) return '7h';
                if (duration === 7.5) return '7h30m';
                if (duration === 8) return '8h';
                if (duration === 8.5) return '8h30m';
                if (duration === 9) return '9h';
                if (duration === 9.5) return '9h30m';
                if (duration === 10) return '10h';
                if (duration === 10.5) return '10h30m';
                if (duration === 11) return '11h';
                if (duration === 11.5) return '11h30m';
                if (duration === 12) return '12h';
                
                // Fallback for any other values
                const hours = Math.floor(duration);
                const minutes = Math.round((duration - hours) * 60);
                if (minutes === 0) return `${hours}h`;
                return `${hours}h${minutes}m`;
            }
            
            saveTodos() {
                localStorage.setItem('weeklyPlannerTodos', JSON.stringify(this.todos));
            }
            
            loadTodos() {
                const saved = localStorage.getItem('weeklyPlannerTodos');
                if (saved) {
                    try {
                        this.todos = JSON.parse(saved);
                    } catch (e) {
                        this.todos = [];
                    }
                }
            }
        }
        
        // Initialize the planner when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new WeeklyPlanner();
            const y = document.getElementById('footerYear');
            if (y) y.textContent = new Date().getFullYear();
        });
    </script>
    
    <!-- App Footer -->
    <footer class="mt-8 bg-dark-card border-t border-dark-border">
        <div class="container mx-auto px-4 py-6 text-center">
            <p class="text-sm text-dark-muted">
                ¬© <span id="footerYear"></span> 
                <a href="https://www.linkedin.com/in/italo-jean-araujo-de-souza/" target="_blank" class="text-game-cyan hover:text-white transition-colors">√çtalo Ara√∫jo</a>. 
                Todos os direitos reservados.
            </p>
        </div>
    </footer>
</body>
</html>
